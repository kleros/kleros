"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const os_1 = require("os");
const promise_pool_1 = __importDefault(require("@supercharge/promise-pool"));
const constants_1 = require("../constants");
const git_1 = require("../git");
const groups_1 = require("../groups");
const child_process_1 = require("../../utils/child_process");
const which_1 = require("../../utils/which");
const path = __importStar(require("path"));
const fs_1 = require("../../utils/fs");
const bash_1 = require("../../utils/bash");
const helpers_1 = require("./helpers");
const MAX_CPUS = os_1.cpus().length;
const langSpec = {
    name: "python",
    findPackagesFromFileList: getPythonPackageDirectories,
    runForPackages,
};
exports.default = langSpec;
const ConfigNamePythonPaths = "sys.path.append";
/**
 * suggestsPythonPackageDir is a predicate that returns
 * true if the filename indicates that the directory
 * where it is located may be the root of a Python
 * package.
 *
 * @param {string} filename a filename
 * @returns {boolean} true if filename suggests it might
 *   be located in the root of a Python package.
 */
function suggestsPythonPackageDir(filename) {
    return (filename.endsWith("pyproject.toml") ||
        filename.endsWith("setup.cfg") ||
        filename.endsWith("setup.py"));
}
async function getPythonPackageDirectories(repoRoot, files) {
    // This will catch directories that are not Python packages because it
    // might match files named, e.g. `test_setup.py`, as well as if someone
    // happens to name a file `setup.py` that is not a Python package setup
    // script. This is ok because runForPackages will filter out
    // misidentified directories when the underlying runForPackage promise
    // rejects.
    const directories = files
        .filter(suggestsPythonPackageDir)
        .map((p) => path.resolve(repoRoot, path.dirname(p)))
        .map((p) => fs_1.ensureTrailingSlash(p));
    // Python projects may have one or more of pyproject.toml, setup.cfg, or
    // setup.py files, so we need to dedupe the directory results.
    return [...new Set(directories)];
}
function shallowestPathCompareFn(a, b) {
    // Splitting on path.sep is a proxy for counting the number
    // of occurrences of path.sep in each input
    const aSegments = a.split(path.sep);
    const bSegments = b.split(path.sep);
    return aSegments.length - bSegments.length;
}
async function runForPackages(repoRoot, allPackageNames, options, config) {
    let pythonInitFiles = [];
    let pythonRegularFiles = [];
    const additionalPythonPaths = extractPythonPathsFrom(config, repoRoot);
    const files = await git_1.enumerateFiles(repoRoot, repoRoot, constants_1.exclusions, []);
    files.forEach((f) => {
        if (f.endsWith(".py")) {
            if (f.endsWith("__init__.py")) {
                pythonInitFiles.push(f);
            }
            else {
                pythonRegularFiles.push(f);
            }
        }
    });
    // Sets iterate through values in insertion order so we order the filename
    // lists by *path depth* from shallowest to deepest before turning them in
    // to Sets.
    pythonInitFiles.sort(shallowestPathCompareFn);
    pythonRegularFiles.sort(shallowestPathCompareFn);
    if ((options === null || options === void 0 ? void 0 : options.mode) === "incremental") {
        if (options.previousDependencyMapCommit && options.fileChangeSet) {
            const filesToProcessSet = helpers_1.getFilesToProcessFromFileChangeSet(options.fileChangeSet);
            pythonInitFiles = pythonInitFiles.filter((filename) => filesToProcessSet.has(filename));
            pythonRegularFiles = pythonRegularFiles.filter((filename) => filesToProcessSet.has(filename));
        }
    }
    const pythonInitFilesSet = new Set(pythonInitFiles);
    const pythonRegularFilesSet = new Set(pythonRegularFiles);
    if (allPackageNames.length === 0 &&
        pythonInitFiles.length === 0 &&
        pythonRegularFiles.length === 0) {
        return { result: undefined, success: true };
    }
    try {
        await ensurePythonUtilsInstalled();
    }
    catch (err) {
        console.error(`\n${chalk_1.default.red(`Error: ${err.message}`)}`);
        return { result: undefined, success: false };
    }
    const moduleToFileMap = new Map();
    const fileToModuleMap = new Map();
    // Process packages
    const { results: packageIntermediateResults, errors: packageErrors } = await promise_pool_1.default.for(allPackageNames)
        .withConcurrency(MAX_CPUS)
        .process(async (p) => {
        return await runForPath(repoRoot, p, "package", allPackageNames, moduleToFileMap, fileToModuleMap, additionalPythonPaths, options);
    });
    packageErrors.forEach((err) => {
        console.error(`\n${chalk_1.default.yellow(`Unable to run for package ${err.item}: ${err.message}`)}`);
    });
    const packageResults = packageIntermediateResults
        .filter((r) => Boolean(r))
        .sort((a, b) => (a.packageName || "").localeCompare(b.packageName || ""));
    // Process modules
    const { results: moduleIntermediateResults, errors: moduleErrors } = await promise_pool_1.default.for(pythonInitFiles)
        .withConcurrency(MAX_CPUS)
        .process(async (initFile) => {
        // If a file is already in the fileToModuleMap, it means pydeps
        // already analyzed this file during the course of our processing.
        if (fileToModuleMap.has(initFile) && (options === null || options === void 0 ? void 0 : options.mode) === "full") {
            return;
        }
        // In incremental mode, we want to explicitly run pydeps to
        // analyze each file in the file change set, so we only return
        // early if the file is not in pythonInitFilesSet. This may be
        // overly cautious. We may be able to skip these files, bu this
        // will require more testing. We can look into this when we
        // begin running makeEnclosingModuleLinks again.
        if (fileToModuleMap.has(initFile) &&
            (options === null || options === void 0 ? void 0 : options.mode) === "incremental" &&
            !pythonInitFilesSet.has(initFile)) {
            return;
        }
        const moduleRelativePath = path.dirname(initFile);
        const moduleAbsolutePath = path.join(repoRoot, moduleRelativePath);
        return await runForPath(repoRoot, moduleAbsolutePath, "module", allPackageNames, moduleToFileMap, fileToModuleMap, additionalPythonPaths, options);
    });
    moduleErrors.forEach((err) => {
        console.error(`\n${chalk_1.default.yellow(`Unable to run for module ${err.item}: ${err.message}`)}`);
    });
    const moduleResults = moduleIntermediateResults
        .filter((r) => Boolean(r))
        .sort((a, b) => (a.packageName || "").localeCompare(b.packageName || ""));
    // Process regular files
    const { results: fileIntermediateResults, errors: fileErrors } = await promise_pool_1.default.for(pythonRegularFiles)
        .withConcurrency(MAX_CPUS)
        .process(async (file) => {
        // If a file is already in the fileToModuleMap, it means pydeps
        // already analyzed this file during the course of our processing.
        if (fileToModuleMap.has(file) && (options === null || options === void 0 ? void 0 : options.mode) === "full") {
            return;
        }
        // In incremental mode, we want to explicitly run pydeps to
        // analyze each file in the file change set, so we only return
        // early if the file is not in pythonRegularFilesSet. This may be
        // overly cautious. We may be able to skip these files, bu this
        // will require more testing. We can look into this when we
        // begin running makeEnclosingModuleLinks again.
        if (fileToModuleMap.has(file) &&
            (options === null || options === void 0 ? void 0 : options.mode) === "incremental" &&
            !pythonRegularFilesSet.has(file)) {
            return;
        }
        const fileAbsolutePath = path.join(repoRoot, file);
        return await runForPath(repoRoot, fileAbsolutePath, "file", allPackageNames, moduleToFileMap, fileToModuleMap, additionalPythonPaths, options);
    });
    fileErrors.forEach((err) => {
        console.error(`\n${chalk_1.default.yellow(`Unable to run for file ${err.item}: ${err.message}`)}`);
    });
    const fileResults = fileIntermediateResults
        .filter((r) => Boolean(r))
        .sort((a, b) => (a.packageName || "").localeCompare(b.packageName || ""));
    const results = [...packageResults, ...moduleResults, ...fileResults];
    if (results.length === 0) {
        console.error(`\n${chalk_1.default.red(`No valid Python packages, modules, or files found in "${repoRoot}".`)}`);
        // Is this really an error?
        return { result: undefined, success: false };
    }
    // We always call mergeResults if there is at least one result.
    // mergeResults will do the right thing if there is only one
    // result.
    const result = mergeResults(repoRoot, results, moduleToFileMap, options);
    const success = packageErrors.length === 0 &&
        moduleErrors.length === 0 &&
        fileErrors.length === 0;
    return { result, success };
}
/**
 * Compute node and link data for a path referencing Python code.
 * @param {string} repoRoot absolute path to the root of the repository
 * @param {string} codePath absolute path containing Python code.
 * @param {"package" | "module" | "file"} pathType is `codePath` a
 *   - package: A directory containing any of setup.cfg, setup.py, or
 *     pyproject.toml files.
 *   - module: A directory containing an __init__.py file
 *   - file: A path to a .py file.
 *   we need this to know how to properly invoke pydeps.
 * @param {string[]} allPackageNames list of all package names
 * @param {PackageMap} moduleToFileMap map from Python modules to
 *   file paths. Initally pass an empty map, and repeated calls to
 *   runForPath will populate it.
 * @param {PackageMap} fileToModuleMap map from file paths to
 *   Python modules. Initally pass an empty map, and repeated calls
 *   to runForPath will populate it. This is the reverse of
 *   `moduleToFileMap`.
 * @param {PackageOptions} options
 *
 * @returns {Promise<MergeResultV4>} Node and link data for `path`
 * @throws {Error} If pydeps fails to run for `path`, or produces
 *   incomplete results
 */
async function runForPath(repoRoot, codePath, pathType, allPackageNames, moduleToFileMap, fileToModuleMap, additionalPythonPaths, options) {
    let targetPath = codePath;
    const targetPathDir = pathType === "file" ? path.dirname(codePath) : codePath;
    let packageName = targetPathDir;
    if (pathType === "package") {
        const packageInfo = await getPackageInfo(targetPath, options);
        if (packageInfo === undefined) {
            const message = `Invalid package "${targetPath}". Skipping.`;
            console.error(`\n${chalk_1.default.yellow(`Warning: ${message}`)}`);
            throw new Error(message);
        }
        const { name, packageSrcDir } = packageInfo;
        // TODO: This name is the human-readable name of a package,
        // It is *not* the thing you import. e.g. for Django, this
        // is "Django" (note upper-case first letter) vs. "django",
        // the latter being what you put in the Python import
        // statement. Should this be the thing you import?
        packageName = name;
        targetPath = packageSrcDir;
    }
    let envs = "";
    let pydepsOutput = "";
    if (additionalPythonPaths) {
        // We use single-quotes around additionalPythonPath to prevent injection attacks
        // For more info on injection: https://owasp.org/Top10/A03_2021-Injection/
        const safeAdditionalPythonPaths = bash_1.escapeForBashSingleQuotes(additionalPythonPaths);
        envs = `PYTHONPATH=$PYTHONPATH':${safeAdditionalPythonPaths}'`;
    }
    try {
        const safeTargetPath = bash_1.escapeForBashSingleQuotes(targetPath);
        const pydepsExecutable = await which_1.which("pydeps");
        const { stdout } = await child_process_1.exec(`${envs} ${pydepsExecutable} --nodot --no-output --show-deps --max-bacon 0 --include-missing '${safeTargetPath}'`, 
        // Buffer up to 8MB of output. Django's dependency data is ~700KB,
        // but we have observed customers with dependency data of ~3MB in size.
        {
            maxBuffer: 1024 * 8000,
            sandbox: options === null || options === void 0 ? void 0 : options.sandbox,
            mountReadOnlyDirectories: [
                repoRoot,
                ...((additionalPythonPaths === null || additionalPythonPaths === void 0 ? void 0 : additionalPythonPaths.split(":").map(bash_1.escapeForBashSingleQuotes)) || []),
            ],
        });
        pydepsOutput = stdout;
    }
    catch (err) {
        console.error(`\n${chalk_1.default.yellow(`pydeps warning: pydeps failed to run for "${targetPath}". Skipping.\nDetails: ${err.message}`)}`);
        throw err;
    }
    const promises = await Promise.all([
        git_1.enumerateFiles(repoRoot, targetPathDir, constants_1.exclusions, allPackageNames),
        pydepsToModuleLinks(repoRoot, JSON.parse(pydepsOutput), moduleToFileMap, fileToModuleMap),
    ]);
    const results = {
        version: constants_1.fileFormatVersion4,
        mode: (options === null || options === void 0 ? void 0 : options.mode) || "full",
        linkLanguages: { python: true },
        packageNamePathLanguages: {},
        // We don't currently do anything with packageName,
        // packageDirectory, and packageNamePaths for Python,
        // but the "well-formed" check expects them to be present.
        packageName: stripRepoRoot(packageName, repoRoot),
        packageDirectory: stripRepoRoot(targetPathDir, repoRoot),
        packageNamePaths: [],
        commitHash: "",
        previousDependencyMapCommit: options === null || options === void 0 ? void 0 : options.previousDependencyMapCommit,
        fileChangeSet: options === null || options === void 0 ? void 0 : options.fileChangeSet,
        configuration: "",
        nodes: promises[0].map((n) => ({ key: n })),
        links: promises[1],
    };
    if (results.packageName &&
        results.packageDirectory !== undefined &&
        results.nodes &&
        results.nodes.length > 0) {
        return results;
    }
    console.error(`\n${chalk_1.default.red(`Error: results incomplete:
packageName: ${results.packageName}
packageDirectory: ${results.packageDirectory}
commitHash: ${results.commitHash}
result.nodes.length: ${results.nodes && results.nodes.length}
`)}`);
    throw new Error(`Invalid ${pathType} "${targetPath}". Skipping.`);
}
function stripRepoRoot(path, repoRoot) {
    // On macOS, if the paths are on a temporary filesystem, they
    // may be prefixed with "/private/". The pydeps utility sees
    // this prefix. There's a pydeps issue related to this:
    // https://github.com/thebjorn/pydeps/issues/41
    //
    // At some point in time our JavaScript code did not see the
    // "/private/" prefix when computing the value of repoRoot.
    //
    // It's unclear if this was a function of the node version,
    // the macOS version, how we invoke Git (we used a JavaScript
    // Git binding called simple-git at one point) or some
    // combination of the preceding.
    //
    // More recently, our JavaScript code started seeing the
    // "/private/" prefix. This function now handles both cases.
    if (path.startsWith("/private") && repoRoot.startsWith("/private")) {
        return path.replace(repoRoot, "");
    }
    return path.replace(/^\/private/, "").replace(repoRoot, "");
}
function pydepsToModuleLinks(repoRoot, data, moduleToFileMap, fileToModuleMap) {
    const res = [];
    for (const [module, info] of Object.entries(data)) {
        const node = info.path === null
            ? null
            : {
                key: stripRepoRoot(info.path, repoRoot),
            };
        if (node !== null) {
            moduleToFileMap.set(module, node.key);
            fileToModuleMap.set(node.key, module);
        }
        // At this point the values of from and to in the links here
        // are Python module names. We'll inflate them to paths later.
        // {
        //   from: "simple_package.tests.test_simple",
        //   to: "simple_package.simple",
        // }
        const links = info.imports === undefined
            ? []
            : info.imports.map((importedModule) => {
                return {
                    from: module,
                    to: importedModule,
                };
            });
        res.push(...links);
    }
    return res;
}
/**
 * ensurePythonUtilsInstalled verifies that codesee-py and pydeps
 * are installed. If they are not present, it will try to install
 * them.
 * @throws {Error} If codesee-py and pydeps are not available,
 *   and cannot be installed
 */
async function ensurePythonUtilsInstalled() {
    const preInstallPaths = await Promise.all([
        which_1.which("codesee-py"),
        which_1.which("pydeps"),
        which_1.which("pip3"),
    ]);
    let codeseePyPath = preInstallPaths[0];
    let pyDepsPath = preInstallPaths[1];
    const pipPath = preInstallPaths[2];
    if (codeseePyPath !== undefined && pyDepsPath !== undefined) {
        return;
    }
    if (pipPath === undefined) {
        throw new Error("Couldn't install Python dependency tooling. pip3 not found.");
    }
    try {
        await child_process_1.exec(`pip3 install -U "codesee-util[pydeps]"`);
    }
    catch (err) {
        throw new Error("Couldn't install Python dependency tooling. pip failure.");
    }
    const postInstallPaths = await Promise.all([
        which_1.which("codesee-py"),
        which_1.which("pydeps"),
    ]);
    codeseePyPath = postInstallPaths[0];
    pyDepsPath = postInstallPaths[1];
    if (codeseePyPath === undefined || pyDepsPath === undefined) {
        throw new Error("Python dependency tooling not found.");
    }
}
/**
 * getPackageInfo returns an object with information about
 * the Python package in the directory specified by path.
 *
 * This calls out to a Python utility because the location
 * of the package source directory depends on the contents of
 * setup.cfg or setup.py, and Python provides tools for
 * interpreting these files.
 * @param {string} path path to the top-level directory of a
 *   Python package in it. This is the directory where at least
 *   one of pyproject.toml, setup.cfg, or setup.py is located.
 * @returns {Promise<PackageInfo | undefined>} Information about
 *   the Python package if it can be determined, otherwise
 *   undefined.
 */
async function getPackageInfo(path, options) {
    try {
        const codeseePy = await which_1.which("codesee-py");
        const safePath = bash_1.escapeForBashSingleQuotes(path);
        const { stdout } = await child_process_1.exec(`${codeseePy} package_info '${safePath}'`, {
            sandbox: options === null || options === void 0 ? void 0 : options.sandbox,
            mountReadOnlyDirectories: [safePath],
        });
        const packageInfo = JSON.parse(stdout);
        // Convert keys from snake_case to camelCase
        const res = {
            name: packageInfo.name,
            packageSrcDir: packageInfo.package_src_dir,
        };
        return res;
    }
    catch (err) {
        console.error(`\n${chalk_1.default.yellow(`codesee-py warning: ${err.message}`)}`);
        return undefined;
    }
}
function mergeResults(repoRoot, unmerged, moduleToFileMap, options) {
    if (unmerged.length === 0) {
        return undefined;
    }
    repoRoot = path.resolve(repoRoot);
    const results = {
        version: constants_1.fileFormatVersion4,
        mode: (options === null || options === void 0 ? void 0 : options.mode) || "full",
        linkLanguages: unmerged[0].linkLanguages,
        packageNamePathLanguages: unmerged[0].packageNamePathLanguages,
        commitHash: unmerged[0].commitHash,
        previousDependencyMapCommit: options === null || options === void 0 ? void 0 : options.previousDependencyMapCommit,
        fileChangeSet: options === null || options === void 0 ? void 0 : options.fileChangeSet,
        packageName: undefined,
        packageNamePaths: [],
        nodes: [],
        links: [],
    };
    results.nodes = dedupeNodes(unmerged.flatMap((r) => r.nodes));
    groups_1.generateMissingGroups(results.nodes);
    results.links = combineLinks(repoRoot, moduleToFileMap, unmerged);
    return results;
}
function dedupeNodes(nodes) {
    // This is used to dedupe based on key value and then we return the filtered
    // nodes. This is necessary because the file viewer will show duplicate nodes,
    // but GoJS actually prunes the duplicate nodes while rendering. :shrug:
    const nodeKeys = new Set();
    return nodes.filter((n) => {
        if (nodeKeys.has(n.key)) {
            return false;
        }
        nodeKeys.add(n.key);
        return true;
    });
}
function combineLinks(_repoRoot, 
// JS version expects packageNameDirMap: PackageMap,
moduleToFileMap, unmerged) {
    const linkIds = new Set();
    // A single list of just module links with no nesting:
    const linksFlattened = unmerged.flatMap((p) => p.links);
    // If we choose to add enclosing module links, this is
    // where we would generate them. After building them,
    // we would concatenate them on to `linksFlattened`,
    // and process the entire list the way we do below.
    // const enclosingLinks = makeEnclosingModuleLinks(
    //   moduleToFileMap,
    //   linksFlattened
    // );
    // We used to filter links with a helper named
    // linkConnectsTwoNodes nodes in the statement below.
    // This was fine when generating a full map, but
    // might cause issues with incremental maps if the
    // node target was not modified in the changeset.
    // This is no longer needed because
    // `pruneNonExistentEntries` in `map/index.ts`
    // accomplishes the same goal in a more robust
    // manner.
    const links = linksFlattened
        .map(makeModuleLinksInToPaths(moduleToFileMap))
        .filter(detectLinkDuplication(linkIds));
    return links;
}
/**
 * makeEnclosingModuleLinks is responsible generating
 * all, i.e. both implicit and explicit, "enclosing"
 * module links which pydeps may not always generate.
 *
 * *NOTE*: This is not currently used!!!! We're concerned
 * that calling this would produce a Codebase Map that,
 * while _technically_ correct, would be potentially
 * overwhelming and less useful to our users
 *
 * We have a potential plan to be able to
 * take the output of this, and prune out the _implicit_
 * imports, while keeping the explicit ones, but it
 * likely requires parsing the AST (abstract syntax tree)
 * for each relevant Python file, and examining any
 * import statements we find. The good news is that
 * Python comes with an `ast` module which does most of
 * the heavy lifting for us. See:
 * https://docs.python.org/3/library/ast.html and
 * https://greentreesnakes.readthedocs.io/en/latest/
 *
 * This is best illustrated with some examples:
 *
 * When a Python file executes an import like:
 *
 * from foo import bar
 *
 * And foo is a directory, Python looks for a file named
 * `__init__.py` in the foo directory. If that file exists,
 * then Python considers foo to be a module, and then looks
 * for a file named `bar.py` in the foo directory.
 *
 * The key here is that this *implicitly* is importing the
 * file `foo/__init__.py` file. This is subtle, but
 * important since __init__.py files _can contain
 * executable code which may run at import time!!!_
 *
 * It's also possible to say, for example
 *
 * import foo
 *
 * This is explicitly importing `foo/__init__.py`, and
 * that's probably meeaningful to our users.
 *
 * @param {PackageMap} moduleToFileMap populated map from
 *   Python modules to file paths.
 * @param {Link[]} links flat list of links we know about
 *
 * @returns {Link[]} a flat list of enclosing module links
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
function makeEnclosingModuleLinks(moduleToFileMap, links) {
    /* eslint-enable @typescript-eslint/no-unused-vars */
    const res = [];
    const alreadyAdded = new Set();
    links.forEach(({ from, to }) => {
        // Here `to` is a Python module like "awscli.autocomplete.autogen"
        let targetParts = to.split(".");
        while (targetParts.length > 1) {
            targetParts = targetParts.slice(0, -1);
            const module = targetParts.join(".");
            const link = { to: module, from };
            const key = linkToKey(link);
            if (!alreadyAdded.has(key)) {
                const file = moduleToFileMap.get(module);
                if (file && file.endsWith("__init__.py")) {
                    // module maps to an __init__.py file so it's a genuine
                    // Python module.
                    res.push(link);
                }
                alreadyAdded.add(key);
            }
        }
    });
    return res;
}
const makeModuleLinksInToPaths = (moduleToFileMap) => ({ from, to }) => {
    return {
        to: moduleToFileMap.get(to) || "",
        from: moduleToFileMap.get(from) || "",
    };
};
/**
 * linkToKey converts a Link with attributes `to`
 * and `from` to a string suitable for use as a
 * key in a Set or Map.
 *
 * @returns {string} string suitable for use as a key in a Set or Map
 */
function linkToKey({ to, from }) {
    return `${to}|${from}`;
}
const detectLinkDuplication = (linkIds) => (l) => {
    const key = linkToKey(l);
    if (linkIds.has(key)) {
        return false;
    }
    linkIds.add(key);
    return true;
};
// If ConfigNamePythonPaths is set in `config`, this function
// returns a string: the absolute paths joined by ":"
const extractPythonPathsFrom = (config, repoRoot) => {
    let relPaths = config[ConfigNamePythonPaths] || [];
    if (typeof relPaths === "string") {
        relPaths = [relPaths];
    }
    if (relPaths instanceof Array) {
        // convert from relative to absolute paths, and join with ":"
        return relPaths
            .map((rel) => {
            if (typeof rel !== "string") {
                return null;
            }
            return path.join(repoRoot, rel);
        })
            .filter((x) => x)
            .join(":");
    }
    console.log(chalk_1.default.yellowBright(`Malformed configuration file. Expected "${ConfigNamePythonPaths}" to be an array`));
    return null;
};
