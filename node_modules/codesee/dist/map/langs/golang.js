"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const os_1 = require("os");
const fs_2 = require("../../utils/fs");
const git_1 = require("../git");
const constants_1 = require("../constants");
const child_process_1 = require("../../utils/child_process");
const bash_1 = require("../../utils/bash");
const helpers_1 = require("./helpers");
const langSpec = {
    name: "golang",
    findPackagesFromFileList,
    runForPackages,
};
const langStrategy = {
    language: "Go",
    ensureToolInstalled: ensureGoDependencyToolInstalled,
    runForPackage,
};
exports.default = langSpec;
const GO_TOOL_VERSION = "0.2.2";
const GO_TOOL_URL = `https://github.com/Codesee-io/codesee-deps-go/releases/download/v${GO_TOOL_VERSION}/codesee-deps-go_${GO_TOOL_VERSION}_${process.platform}_${process.arch}.tar.gz`;
const GO_TOOL_BASE = path_1.default.join(os_1.tmpdir(), "codesee", "codesee-deps-go");
const GO_TOOL_TAR = path_1.default.join(GO_TOOL_BASE, "codesee-deps-go.tar.gz");
const GO_TOOL_PATH = path_1.default.join(GO_TOOL_BASE, "codesee-deps-go");
async function findPackagesFromFileList(repoRoot, files) {
    const directories = files
        .filter((p) => p.endsWith("go.mod"))
        // We don't want to include any vendored packages.
        .filter((p) => !(p.startsWith("vendor/") || p.includes("/vendor/")))
        .map((p) => path_1.default.resolve(repoRoot, path_1.default.dirname(p)))
        .map((p) => fs_2.ensureTrailingSlash(p))
        .sort();
    // Our Go dependency tool will correctly find all of the links between files
    // even if there is another Go module that's nested within a parent module. So
    // if there's a/go.mod and a/b/c/go.mod, running the tool for a will
    // successfully get the dependencies for a/b/c as well. Because of this, we
    // need to filter out any child modules to avoid unnecessary any work.
    let lastDirectory;
    return directories.filter((directory) => {
        // Because we sorted the directories, any parents would be directory before
        // its children, so we can reliably check the last directory (which wasn't a
        // child) to see if it's also a child.
        if (lastDirectory && directory.startsWith(lastDirectory)) {
            return false;
        }
        lastDirectory = directory;
        return true;
    });
}
async function runForPackages(repoRoot, allPackageNames, options) {
    return helpers_1.runForPackagesWithStrategy(repoRoot, allPackageNames, langStrategy, options);
}
async function runForPackage(repoRoot, packageDir, packageNames, options) {
    const promises = await Promise.all([
        getPackageName(packageDir),
        git_1.enumerateFiles(repoRoot, packageDir, constants_1.exclusions, packageNames),
        runGoDeps(packageDir, options),
    ]);
    const results = {
        version: constants_1.fileFormatVersion4,
        mode: (options === null || options === void 0 ? void 0 : options.mode) || "full",
        linkLanguages: { golang: true },
        packageNamePathLanguages: {},
        packageName: promises[0],
        packageDirectory: packageDir.replace(repoRoot, ""),
        packageNamePaths: [],
        commitHash: "",
        previousDependencyMapCommit: options === null || options === void 0 ? void 0 : options.previousDependencyMapCommit,
        fileChangeSet: options === null || options === void 0 ? void 0 : options.fileChangeSet,
        configuration: "",
        nodes: promises[1].map((n) => ({ key: n })),
        links: promises[2],
    };
    if (results.nodes && results.nodes.length > 0) {
        return results;
    }
    else {
        throw new Error(`Invalid package "${packageDir}". Skipping.`);
    }
}
async function getPackageName(baseDir) {
    const filename = path_1.default.join(baseDir, "go.mod");
    try {
        const goModContents = await fs_1.promises.readFile(filename);
        const matches = goModContents.toString().match(/module (.*)/);
        if (matches) {
            return matches[1];
        }
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return undefined;
        }
        else {
            console.error(chalk_1.default.red(`Unable to read module name for ${baseDir}`));
            throw err;
        }
    }
}
async function runGoDeps(repoRoot, options) {
    // The environment variable is used for development only,
    // no need to set this anywhere but in development
    const toolPath = process.env.CODESEE_GO_DEPS_PATH || GO_TOOL_PATH;
    const safeRepoRoot = bash_1.escapeForBashSingleQuotes(repoRoot);
    const { stdout } = await child_process_1.exec(`${toolPath} '${safeRepoRoot}'`, {
        // ~8MB of output buffer, kubernetes is around 4MBs
        maxBuffer: 1024 * 8000,
        sandbox: options === null || options === void 0 ? void 0 : options.sandbox,
        mountReadOnlyDirectories: [safeRepoRoot, GO_TOOL_BASE, toolPath],
    });
    return JSON.parse(stdout);
}
async function ensureGoDependencyToolInstalled() {
    return helpers_1.ensureDependencyToolInstalled(langSpec.name, GO_TOOL_BASE, GO_TOOL_PATH, GO_TOOL_URL, GO_TOOL_TAR, GO_TOOL_VERSION);
}
