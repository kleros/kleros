"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runForPackages = void 0;
const package_management_1 = require("./package-management");
const groups_1 = require("../../groups");
const git_1 = require("../../git");
const helpers_1 = require("../helpers");
const constants_1 = require("../../constants");
const path_1 = __importDefault(require("path"));
const resolve_1 = require("./resolve");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("../../../utils/fs");
/**
 * Within js-deps, we attempt to be very explicit about paths:
 *  - any absolute path will have "abs" in the name, and be of type AbsolutePath
 *  - any relative path will have "rel" in the name, as well as what the base is
 *    (e.g. fileRelRootPaths is an array that hold paths relative to the repo root)
 *  - any path for a directory will be assumed to have NO trailing slash
 *  - if a path has a trailing slash, it will be explicit in the name (e.g. dirWithTrailingSlash)
 */
/***
 * TODO:
    Additional cases to cover:
     - test file is a .js file, and it imports a .ts file (this does work, see the spec.js files in this very project)
     - find webpack config and use its alias info (but not if this is an insecure environment)
 */
async function runForPackages(repoRootAbsPathWithTrailingSlash, packageDirAbsPaths, options) {
    if (packageDirAbsPaths.length === 0) {
        return { result: undefined, success: true };
    }
    const repoRootAbsPath = fs_1.ensureNoTrailingSlash(repoRootAbsPathWithTrailingSlash);
    const packageInfos = package_management_1.getPackageInfoFromPackageDirAbsPaths(repoRootAbsPath, packageDirAbsPaths);
    const externalPackageNames = await package_management_1.getAllExternalPackageNames(repoRootAbsPath);
    let incrementalFileRootRelPathsToProcess;
    if ((options === null || options === void 0 ? void 0 : options.mode) === "incremental" &&
        options.previousDependencyMapCommit &&
        options.fileChangeSet) {
        incrementalFileRootRelPathsToProcess = helpers_1.getFilesToProcessFromFileChangeSet(options.fileChangeSet);
    }
    if (packageInfos.length === 1) {
        return await runForOnePackage(repoRootAbsPath, packageInfos[0], packageDirAbsPaths, externalPackageNames, options, incrementalFileRootRelPathsToProcess);
    }
    else {
        return await runForMultiplePackages(repoRootAbsPath, packageInfos, packageDirAbsPaths, externalPackageNames, options, incrementalFileRootRelPathsToProcess);
    }
}
exports.runForPackages = runForPackages;
async function runForOnePackage(repoRootAbsPath, packageInfo, packageDirAbsPaths, externalPackageNames, options, incrementalFileRootRelPathsToProcess) {
    const localPackageNames = new Set();
    const lookupGroupKeyByPackageName = new Map();
    if (packageInfo.name) {
        localPackageNames.add(packageInfo.name);
        lookupGroupKeyByPackageName.set(packageInfo.name, packageInfo.absDirPath);
    }
    try {
        const { result, success } = await runForPackage(repoRootAbsPath, // root
        {
            ...packageInfo,
            name: packageInfo.name || "<This package has no name>",
            absDirPath: repoRootAbsPath,
        }, packageDirAbsPaths, // all package paths
        localPackageNames, externalPackageNames, new Set(), lookupGroupKeyByPackageName, options, incrementalFileRootRelPathsToProcess);
        if (result) {
            // We remove this because it's only needed in the case of monorepos when we need to merge the results from the
            // individual packages into a mega-diagram. Since packageDirectory isn't part of schema, we want to make sure it
            // doesn't end up in the output
            delete result.packageDirectory;
            groups_1.generateMissingGroups(result.nodes);
        }
        return { result, success };
    }
    catch (err) {
        console.error(chalk_1.default.yellow(`Unable to run for package ${packageInfo.name || packageInfo.absDirPath}: ${err.message}`));
        return { result: undefined, success: false };
    }
}
async function runForMultiplePackages(repoRootAbsPath, packageInfos, packageDirAbsPaths, externalPackageNames, options, incrementalFileRootRelPathsToProcess) {
    const namedPackageInfos = packageInfos.filter((info) => info.name && info.name !== "");
    const localPackageNames = getSafeLocalPackageNamesFromPackageInfos(namedPackageInfos);
    const safePackageInfos = namedPackageInfos.filter((info) => localPackageNames.has(info.name));
    // This lookup is used to resolve dependencies to a package.
    // We use the SAFE packageInfos because duplicate package names are
    // already filtered out, so we don't have to guess which package to
    // link to when such a name is found.
    const lookupGroupKeyByPackageName = generateGroupKeyByPackageNameLookup(repoRootAbsPath, safePackageInfos);
    // sort packages so that deeper nested packages run first
    const sortedPackageInfos = [...namedPackageInfos];
    sortedPackageInfos.sort((a, b) => b.absDirPath.split("/").length - a.absDirPath.split("/").length);
    const visitedFileRootRelPaths = new Set();
    const results = [];
    let success = true;
    // for each package dir (deeper folders first)
    for (const packageInfo of sortedPackageInfos) {
        try {
            // Do not run packages in parallel, or we will not be able to
            // prevent the same file from being examined multiple times.
            const { result, success: runSuccess } = await runForPackage(repoRootAbsPath, // root
            packageInfo, packageDirAbsPaths, // all package paths
            localPackageNames, externalPackageNames, visitedFileRootRelPaths, lookupGroupKeyByPackageName, options, incrementalFileRootRelPathsToProcess);
            if (result) {
                results.push(result);
            }
            if (!runSuccess) {
                success = false;
            }
        }
        catch (err) {
            console.error(chalk_1.default.yellow(`Unable to run for package ${packageInfo.name}: ${err.message}`));
            success = false;
        }
    }
    const result = mergeJavascriptResults(results);
    result.packageNamePaths = namedPackageInfos.map((info) => [
        relPathFromAbs(info.absDirPath, repoRootAbsPath),
        info.name,
    ]);
    return { result, success };
}
async function runForPackage(repoRootAbsPath, packageInfo, packageDirAbsPaths, localPackageNames, externalPackageNames, visitedFileRootRelPaths, lookupPackageRootRelDirByName, options, incrementalFileRootRelPathsToProcess) {
    // get a list of all files under this package
    const allFileRootRelPaths = await git_1.enumerateFiles(repoRootAbsPath, packageInfo.absDirPath, [], // TODO: no exclusions, can enumerateFiles be simpler?
    packageDirAbsPaths);
    // if we're running in incremental mode, filter out files that we don't need
    // to process
    let fileRootRelPathsToProcess = allFileRootRelPaths;
    if (incrementalFileRootRelPathsToProcess) {
        fileRootRelPathsToProcess = allFileRootRelPaths.filter((filename) => {
            return incrementalFileRootRelPathsToProcess.has(filename);
        });
    }
    // trim files we've visited before
    const newFileRootRelPaths = fileRootRelPathsToProcess.filter((filePath) => !visitedFileRootRelPaths.has(filePath));
    // mark all these files as visited
    newFileRootRelPaths.forEach((filePath) => visitedFileRootRelPaths.add(filePath));
    const result = {
        version: constants_1.fileFormatVersion4,
        mode: (options === null || options === void 0 ? void 0 : options.mode) || "full",
        linkLanguages: { javascript: true },
        packageNamePathLanguages: {},
        packageName: packageInfo.name,
        packageDirectory: relPathFromAbs(packageInfo.absDirPath, repoRootAbsPath),
        packageNamePaths: [],
        commitHash: "",
        previousDependencyMapCommit: options === null || options === void 0 ? void 0 : options.previousDependencyMapCommit,
        fileChangeSet: options === null || options === void 0 ? void 0 : options.fileChangeSet,
        configuration: "",
        nodes: newFileRootRelPaths.map((n) => ({
            key: n,
            packageName: packageInfo.name,
        })),
        links: getLinks(repoRootAbsPath, newFileRootRelPaths, packageInfo, localPackageNames, externalPackageNames, lookupPackageRootRelDirByName),
    };
    if (result.packageName !== undefined &&
        result.packageDirectory !== undefined &&
        result.nodes &&
        result.nodes.length > 0) {
        return { result, success: true };
    }
    if ((options === null || options === void 0 ? void 0 : options.mode) === "incremental") {
        console.error(chalk_1.default.gray(`No changes detected in ${relPathFromAbs(packageInfo.absDirPath, repoRootAbsPath)} while running in incremental mode. Skipping.`));
        return { result: undefined, success: true };
    }
    console.error(chalk_1.default.yellow(`Invalid package "${relPathFromAbs(packageInfo.absDirPath, repoRootAbsPath)}". Skipping.`));
    // We're still returning success even though it's an invalid package because
    // the purpose of `success` is to determine if an error occurred during
    // processing, and we need to potentially fix something. But there's no action
    // we need to take if the user has an invalid package.
    return { result: undefined, success: true };
}
function mergeJavascriptResults(results) {
    const allNodes = [...new Set(results.flatMap((result) => result.nodes))];
    // this creates groups and modifies allNodes in place
    groups_1.generateMissingGroups(allNodes);
    const linksMap = new Map();
    results
        .flatMap((result) => result.links)
        .forEach((link) => {
        linksMap.set(link.from + link.to, link);
    });
    const allLinks = [...linksMap.values()];
    return {
        ...results[0],
        configuration: undefined,
        packageName: undefined,
        packageDirectory: undefined,
        packageNamePaths: [],
        nodes: allNodes,
        links: allLinks,
    };
}
const extensionRegex = /\.(js|jsx|ts|tsx)$/;
function getLinks(repoRootAbsPath, allFileRootRelPaths, packageInfo, locPackageNames, extPackageNames, lookupPackageRootRelDirByName) {
    const links = [];
    const config = {};
    if (packageInfo.tsConfig) {
        config.tsConfig = packageInfo.tsConfig;
    }
    for (const filePath of allFileRootRelPaths) {
        try {
            const linksForThisFile = findLinks(filePath, repoRootAbsPath, locPackageNames, extPackageNames, lookupPackageRootRelDirByName, config);
            for (const to of linksForThisFile) {
                links.push({
                    from: filePath,
                    to,
                });
            }
        }
        catch (error) {
            console.warn(chalk_1.default.yellow(`Unable to detect dependencies for file: ${filePath}`));
        }
    }
    return links;
}
function findLinks(filePath, repoRootAbsPath, locPackageNames, extPackageNames, lookupPackageRootRelDirByName, config) {
    const linksForThisFile = new Set();
    if (extensionRegex.test(filePath)) {
        const dependencies = resolve_1.resolveFileDependencies({ absFilePath: path_1.default.resolve(repoRootAbsPath, filePath) }, { absFilePath: repoRootAbsPath }, locPackageNames, extPackageNames, config);
        for (const dep of dependencies) {
            switch (dep.type) {
                case "localFile":
                    linksForThisFile.add(relPathFromAbs(dep.absFilePath, repoRootAbsPath));
                    break;
                case "localPackage":
                    const packageRootRelPath = lookupPackageRootRelDirByName.get(dep.name);
                    if (packageRootRelPath) {
                        linksForThisFile.add(packageRootRelPath);
                    }
                    else {
                        // We've deliberately excluded this package from the mapping.
                        // We do this when there are multiple packages with the same name, and we don't want to guess
                    }
                    break;
                case "packageDir":
                    linksForThisFile.add(relPathFromAbs(dep.absDirPath, repoRootAbsPath));
                    break;
                case "partial":
                    // This means we were unable to associate this partial with a file or package
                    // Every one of these is a potential area for improvement of our dependency resolution
                    console.log(chalk_1.default.gray(`Unresolved dependency '${dep.name}' for ${filePath}`));
                    break;
            }
        }
    }
    return linksForThisFile;
}
function generateGroupKeyByPackageNameLookup(repoRootAbsPath, packageInfos) {
    const lookupGroupKeyByPackageName = new Map();
    for (const packageInfo of packageInfos) {
        let groupKey = relPathFromAbs(packageInfo.absDirPath, repoRootAbsPath);
        groupKey = fs_1.ensureNoTrailingSlash(groupKey);
        if (lookupGroupKeyByPackageName.has(packageInfo.name)) {
            console.warn(chalk_1.default.yellow("Found multiple package.json with the same package name: " +
                packageInfo.name));
            const lastDir = lookupGroupKeyByPackageName.get(packageInfo.name);
            if (groupKey.length < lastDir.length) {
                // prefer the longer path -- I suppose :shrug:
                continue;
            }
        }
        lookupGroupKeyByPackageName.set(packageInfo.name, groupKey);
    }
    return lookupGroupKeyByPackageName;
}
/**
 * Get a Set of package names, given packageInfos.
 *
 * Note: By "safe", we mean that -- if there are multiple local packages
 *       with the same name, we are going to exclude that package from the Set
 *
 * @param packageInfos PackageInfo[]
 */
//
function getSafeLocalPackageNamesFromPackageInfos(packageInfos) {
    const nameCount = new Map();
    packageInfos.forEach((packageInfo) => {
        let currentCount = nameCount.get(packageInfo.name) || 0;
        currentCount += 1;
        nameCount.set(packageInfo.name, currentCount);
    });
    const namesSet = new Set();
    nameCount.forEach((count, name) => {
        if (count === 1) {
            namesSet.add(name);
        }
        else {
            console.warn(chalk_1.default.yellow(`Found ${count} package.json with the same package name: ${name}. Skipping to avoid confusion. Please use unique names for your packages if possible.`));
        }
    });
    return namesSet;
}
function relPathFromAbs(absPath, rootAbsPath) {
    const lastCharOfRootPath = rootAbsPath[rootAbsPath.length - 1];
    const offsetForTrailingSlash = lastCharOfRootPath === "/" ? 0 : 1;
    return absPath.substr(rootAbsPath.length + offsetForTrailingSlash);
}
