"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePartial = exports.resolveFileDependencies = void 0;
// There are no types for precinct, and I failed completely to get a .d.ts file to work
// eslint-disable-next-line @typescript-eslint/no-var-requires
const precinct = require("precinct");
const filing_cabinet_1 = __importDefault(require("filing-cabinet"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const nodeBuiltIns = new Set(require("repl")._builtinLibs);
function resolveFileDependencies(file, rootDir, localPackageNames, extPackageNames, configs) {
    const partials = allPartialsForFile(file);
    return partials.map((partial) => resolvePartial(partial, file, rootDir, localPackageNames, extPackageNames, configs));
}
exports.resolveFileDependencies = resolveFileDependencies;
function allPartialsForFile(file) {
    try {
        return precinct.paperwork(file.absFilePath, {
            es6: { mixedImports: true },
            ts: { mixedImports: true },
            tsx: { mixedImports: true, jsx: true },
        });
    }
    catch (error) {
        // maybe it's a TSX file with a TS extension... or vice versa 🤷‍♂️
        const partials = precinct.paperwork(file.absFilePath, {
            es6: { mixedImports: true },
            ts: { mixedImports: true, jsx: true },
            tsx: { mixedImports: true },
        });
        console.warn(chalk_1.default.magentaBright(`This file has the wrong extension, either .ts or .tsx: ${file.absFilePath}`));
        console.warn(chalk_1.default.magentaBright(`We figured it out, but not everyone will. Best to rename it when you get a chance!`));
        return partials;
    }
}
/**
 * A partial dependency is the string written in the code that ambiguously references another module or package
 * For example
 *    import foo from "bar";
 *    const baz = require("./goo");
 *
 * Here, "bar" and "./goo" are partial dependencies
 *
 * This function can __resolve__ "bar" and "./goo" into:
 *    { type: "extPackage", name: "bar" }
 *    { type: "localFile", absFilePath: "/etc/opts/codebase/src/goo.ts"}
 *
 * Note: this is only exported for testing
 */
function resolvePartial(partial, filename, directory, localPackageNames, extPackageNames, configs) {
    // might be a relative path, or might be using an alias that makes it look like a package name
    const resolvedTo = resolvePartialOfRelativePath(partial, filename, directory, configs);
    if (resolvedTo.type !== "partial") {
        return resolvedTo;
    }
    if (partial[0] === "." || partial[0] === "/") {
        // must be a relative path, don't try anything else
        return resolvedTo;
    }
    else {
        // not a relative path, not using an alias, check for a package
        return resolvePartialOfPackageName(partial, localPackageNames, extPackageNames);
    }
}
exports.resolvePartial = resolvePartial;
function resolvePartialOfRelativePath(partial, filename, directory, configs) {
    let resolve;
    // try without the webpack config
    try {
        resolve = filing_cabinet_1.default({
            partial,
            filename: filename.absFilePath,
            directory: directory.absFilePath,
            tsConfig: configs.tsConfig,
        });
        if (resolve !== "") {
            return { type: "localFile", absFilePath: resolve };
        }
        // try with the webpack config
        if (resolve === "" && configs.webpackConfig) {
            resolve = filing_cabinet_1.default({
                partial,
                filename: filename.absFilePath,
                directory: directory.absFilePath,
                webpackConfig: configs.webpackConfig,
                tsConfig: configs.tsConfig,
            });
        }
        if (resolve !== "") {
            return { type: "localFile", absFilePath: resolve };
        }
    }
    catch (err) {
        console.error(chalk_1.default.redBright(`Something went wrong trying to resolve partial '${partial}' for file '${filename.absFilePath}'\n${err}`));
    }
    // Maybe it's referencing a package folder.
    // FilingCabinet won't always do the right thing in this case,
    // because it expects referenced files to exist, and when those
    // are build artifacts, we can't depend on that.
    const fileDirAbsPath = path_1.default.dirname(filename.absFilePath);
    const dependencyAbsPath = path_1.default.join(fileDirAbsPath, partial);
    if (fs_1.default.existsSync(dependencyAbsPath) &&
        fs_1.default.lstatSync(dependencyAbsPath).isDirectory()) {
        // this is a directory
        const packageJsonAbsPath = path_1.default.join(dependencyAbsPath, "package.json");
        if (fs_1.default.existsSync(packageJsonAbsPath)) {
            try {
                const json = JSON.parse(fs_1.default.readFileSync(packageJsonAbsPath, "utf8"));
                if (json.name) {
                    return {
                        type: "packageDir",
                        absDirPath: dependencyAbsPath,
                        name: json.name,
                    };
                }
            }
            catch (error) {
                // invalid package.json
                console.log(chalk_1.default.yellow("Unable to parse package.json at: " + packageJsonAbsPath));
                return { type: "packageDir", absDirPath: dependencyAbsPath };
            }
        }
    }
    return { type: "partial", name: partial };
}
function resolvePartialOfPackageName(partial, localPackageNames, extPackageNames) {
    // compare against known local packages
    const names = possiblePackageNames(partial);
    for (const name of names) {
        if (localPackageNames.has(name)) {
            return { type: "localPackage", name };
        }
    }
    for (const name of names) {
        if (extPackageNames.has(name)) {
            return { type: "extPackage", name };
        }
    }
    for (const name of names) {
        if (nodeBuiltIns.has(name)) {
            return { type: "extPackage", name };
        }
    }
    return { type: "partial", name: partial };
}
function possiblePackageNames(partial) {
    if (partial[0] === ".") {
        return [];
    }
    const chunks = partial.split("/");
    if (chunks.length == 1) {
        return [chunks[0]];
    }
    if (chunks.length > 1) {
        return [chunks[0], chunks[0] + "/" + chunks[1]];
    }
    return [];
}
