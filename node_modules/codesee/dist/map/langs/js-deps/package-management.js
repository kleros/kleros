"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllExternalPackageNames = exports.getPackageInfoFromPackageDirAbsPaths = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
// eslint-disable-next-line @typescript-eslint/no-var-requires
const lockfile = require("@yarnpkg/lockfile");
const which_1 = require("../../../utils/which");
const child_process_1 = require("../../../utils/child_process");
const fs_2 = require("../../../utils/fs");
const chalk_1 = __importDefault(require("chalk"));
const bash_1 = require("../../../utils/bash");
function getPackageInfoFromPackageDirAbsPaths(repoRootAbsPath, packageDirAbsPaths) {
    const packages = new Map();
    // fetch json and tsconfig
    for (const path of packageDirAbsPaths) {
        const json = getJsonFromPackageDirAbsPath(path);
        if (!json) {
            continue;
        }
        const tsConfig = findTsConfigFromPackageDirAbsPath(path);
        packages.set(path, {
            absDirPath: path,
            name: json.name,
            tsConfig,
        });
    }
    // if there's configuration at the repo root, but no package, keep it around
    let rootTsConfig;
    if (!packages.has(repoRootAbsPath)) {
        rootTsConfig = findTsConfigFromPackageDirAbsPath(repoRootAbsPath);
    }
    // bubble up configuration
    // If there's no tsconfig.json in the folder with the package.json file,
    // check its parent directory, then its parent, etc.
    for (const packageInfo of packages.values()) {
        if (packageInfo.tsConfig) {
            continue;
        }
        // go up directory tree looking for a tsconfig
        let dirname = path_1.default.dirname(packageInfo.absDirPath);
        while (dirname !== "/" && dirname !== ".") {
            if (packages.has(dirname)) {
                const parentPackageInfo = packages.get(dirname);
                if (parentPackageInfo.tsConfig) {
                    packageInfo.tsConfig = parentPackageInfo.tsConfig;
                    break;
                }
            }
            dirname = path_1.default.dirname(dirname);
        }
        // if can't find any other one, use the tsconfig at the repo root
        if (!packageInfo.tsConfig && rootTsConfig) {
            packageInfo.tsConfig = rootTsConfig;
        }
    }
    return [...packages.values()];
}
exports.getPackageInfoFromPackageDirAbsPaths = getPackageInfoFromPackageDirAbsPaths;
function getJsonFromPackageDirAbsPath(packageDirAbsPath) {
    try {
        const packageJson = fs_1.default.readFileSync(path_1.default.join(packageDirAbsPath, "package.json"), "utf8");
        return JSON.parse(packageJson);
    }
    catch (error) {
        console.warn(chalk_1.default.yellow(`Unable to read or parse package.json: ${packageDirAbsPath}/package.json`));
        return;
    }
}
function findTsConfigFromPackageDirAbsPath(packageDirAbsPath) {
    try {
        const tsConfigAbsPath = path_1.default.join(packageDirAbsPath, "tsconfig.json");
        // it's important to check for access here, otherwise filing-cabinet will throw
        // for every file that uses this tsconfig
        if (fs_2.canAccessSync(tsConfigAbsPath)) {
            return tsConfigAbsPath;
        }
    }
    catch (error) {
        console.warn(chalk_1.default.yellow(`Unable to access tsconfig.json: ${packageDirAbsPath}/tsconfig.json`));
        return;
    }
}
async function getAllExternalPackageNames(projectRootFullPath) {
    const yarnLockRelPaths = await allMatchingRelPathsFromGit(projectRootFullPath, "yarn.lock");
    const packageLockRelPaths = await allMatchingRelPathsFromGit(projectRootFullPath, "package-lock.json");
    const allPackageNames = new Set();
    addPackageNames(yarnLockRelPaths, allPackageNames, projectRootFullPath, getAllPackageNamesFromYarnLock);
    addPackageNames(packageLockRelPaths, allPackageNames, projectRootFullPath, getAllPackageNamesFromPackageLock);
    return allPackageNames;
}
exports.getAllExternalPackageNames = getAllExternalPackageNames;
function addPackageNames(lockFileRelPaths, allPackageNames, projectRootFullPath, getAllPackageNamesFromLockFile) {
    lockFileRelPaths.forEach((relPath) => {
        const lockFileAbsPath = path_1.default.resolve(projectRootFullPath, relPath);
        const packageNames = getAllPackageNamesFromLockFile(lockFileAbsPath);
        for (const name of packageNames.values()) {
            allPackageNames.add(name);
        }
    });
}
function getAllPackageNamesFromYarnLock(yarnLockAbsPath) {
    try {
        const yarnLock = fs_1.default.readFileSync(yarnLockAbsPath, "utf8");
        const json = lockfile.parse(yarnLock);
        let packageNamesWithVersion = [];
        if (json.type === "success") {
            packageNamesWithVersion = Object.keys(json.object);
        }
        const allPackageNames = new Set(packageNamesWithVersion.map((name) => {
            const pieces = name.split("@");
            return name[0] === "@" ? "@" + pieces[1] : pieces[0];
        }));
        return allPackageNames;
    }
    catch (error) {
        console.warn(chalk_1.default.yellow(`Unable to parse yarn.lock: ${yarnLockAbsPath}`));
    }
    return new Set();
}
function getAllPackageNamesFromPackageLock(lockFileAbsPath) {
    try {
        const packageLock = fs_1.default.readFileSync(lockFileAbsPath, "utf8");
        const json = JSON.parse(packageLock);
        if (json.lockfileVersion <= 2) {
            return new Set(Object.keys(json.dependencies));
        }
    }
    catch (error) {
        console.warn(chalk_1.default.yellow(`Unable to parse package-lock.json: ${lockFileAbsPath}`));
    }
    return new Set();
}
// Given a filename (e.g. "package.json"),
// find all files with that name in this git repo
async function allMatchingRelPathsFromGit(projectRootFullPath, filename) {
    const git = await which_1.which("git");
    const safeFilename = bash_1.escapeForBashSingleQuotes(filename);
    const { stdout: results } = await child_process_1.exec([
        git,
        "-c",
        "core.quotepath=off",
        "ls-files",
        `'${safeFilename}'`,
        `'**/${safeFilename}'`,
    ].join(" "), {
        cwd: projectRootFullPath,
    });
    return results.split("\n").filter((x) => x !== "");
}
