"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("../../utils/child_process");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const bash_1 = require("../../utils/bash");
const fs_2 = require("../../utils/fs");
const constants_1 = require("../constants");
const helpers_1 = require("./helpers");
const console_1 = require("console");
const which_1 = require("../../utils/which");
const langSpec = {
    name: "rust",
    findPackagesFromFileList,
    runForPackages,
};
exports.default = langSpec;
const langStrategy = {
    language: "Rust",
    ensureToolInstalled: ensureRustDependencyToolInstalled,
    runForPackage,
};
const RUST_TOOL_VERSION = "0.2.6";
const RUST_TOOL_URL_BASE = "https://codesee-docs.s3.amazonaws.com/temp-dep-tools";
const RUST_TOOL_URL = `${RUST_TOOL_URL_BASE}/codesee-deps-rust_${RUST_TOOL_VERSION}_${process.platform}_${process.arch}.tar.gz`;
const RUST_TOOL_BASE = path_1.default.join(os_1.tmpdir(), "codesee", "codesee-deps-rust");
const RUST_TOOL_TAR = path_1.default.join(RUST_TOOL_BASE, "codesee-deps-rust.tar.gz");
const RUST_TOOL_PATH = path_1.default.join(RUST_TOOL_BASE, "codesee-deps-rust");
const RUST_MOUNT_DIRECTORIES = [
    path_1.default.join(process.env.HOME || "", ".cargo"),
    path_1.default.join(process.env.HOME || "", ".rustup"),
    RUST_TOOL_BASE,
];
async function findPackagesFromFileList(repoRoot, files, options) {
    const dirPromises = await Promise.allSettled(files
        .filter((p) => p.endsWith("Cargo.toml"))
        // Filter out any Cargo.toml files in the cargo cache, in case someone checks in their cargo cache.
        .filter((p) => !p.includes("/.cargo/"))
        .map((p) => path_1.default.resolve(repoRoot, path_1.default.dirname(p)))
        .map((p) => fs_2.ensureTrailingSlash(p))
        .map((p) => getCargoWorkspaceRoot(`${p}Cargo.toml`, options)));
    const directories = new Set(dirPromises
        .map((dp) => {
        if (dp.status === "fulfilled") {
            return dp.value;
        }
        else {
            return null;
        }
    })
        .filter((p) => Boolean(p)));
    const errors = dirPromises
        .map((dp) => {
        if (dp.status === "rejected") {
            return dp.reason;
        }
        else {
            return null;
        }
    })
        .filter((p) => Boolean(p));
    if (errors.length > 0) {
        const summary_path = process.env["GITHUB_STEP_SUMMARY"];
        if (summary_path) {
            await appendErrorSummaryToFile(summary_path, errors);
        }
        else {
            errors.forEach((err) => {
                console.error(chalk_1.default.red(`Rust error: ${err}`));
            });
        }
    }
    return [...directories];
}
async function appendErrorSummaryToFile(output, errors) {
    const formatted_errors = errors.map((e) => `\'\'\'${e}\'\'\'\n\n`).join("");
    const message = `### Rust Detection Diagnostics

${formatted_errors}
  `;
    return fs_1.promises.writeFile(output, message, { flag: "a+" });
}
async function runForPackages(repoRoot, allPackageNames, options) {
    return helpers_1.runForPackagesWithStrategy(repoRoot, allPackageNames, langStrategy, options);
}
async function runForPackage(repoRoot, packageDir, _allPackageNames, options) {
    const promises = await Promise.all([
        getPackageName(packageDir),
        runRustDeps(packageDir, options),
    ]);
    const results = {
        version: constants_1.fileFormatVersion4,
        mode: (options === null || options === void 0 ? void 0 : options.mode) || "full",
        linkLanguages: { rust: true },
        packageNamePathLanguages: {},
        packageName: promises[0],
        packageDirectory: packageDir.replace(repoRoot, ""),
        packageNamePaths: [],
        commitHash: "",
        previousDependencyMapCommit: options === null || options === void 0 ? void 0 : options.previousDependencyMapCommit,
        fileChangeSet: options === null || options === void 0 ? void 0 : options.fileChangeSet,
        configuration: "",
        nodes: promises[1].nodes,
        links: promises[1].links,
    };
    if (results.nodes && results.nodes.length > 0) {
        return results;
    }
    else {
        throw new Error(`Invalid package "${packageDir}". Skipping.`);
    }
}
async function getPackageName(baseDir) {
    const filename = path_1.default.join(baseDir, "Cargo.toml");
    try {
        const cargoContent = await fs_1.promises.readFile(filename);
        const matches = cargoContent.toString().match(/^name\s*=\s*"[^\"]+"/);
        if (matches) {
            return matches[1];
        }
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return undefined;
        }
        else {
            console.error(chalk_1.default.red(`Unable to read crate name for ${baseDir}`));
        }
    }
}
async function runRustDeps(repoRoot, options) {
    const safeRepoRoot = bash_1.escapeForBashSingleQuotes(repoRoot);
    const env = process.env["CODESEE_RUST_DEBUG"]
        ? {
            ...process.env,
            RUST_LOG: "codesee_deps_rust=trace,codesee_deps_rust::module_finding=warn",
        }
        : process.env;
    // The environment variable is used for development only,
    // no need to set this anywhere but in development
    const toolPath = process.env.CODESEE_RUST_DEPS_PATH || RUST_TOOL_PATH;
    const { stdout, stderr } = await child_process_1.exec(`${toolPath} '${safeRepoRoot}'`, {
        maxBuffer: 1024 * 8000,
        env,
        sandbox: options === null || options === void 0 ? void 0 : options.sandbox,
        mountReadOnlyDirectories: [
            ...RUST_MOUNT_DIRECTORIES,
            safeRepoRoot,
            toolPath,
        ],
    });
    if (process.env["CODESEE_RUST_DEBUG"]) {
        const logger = new console_1.Console(process.stderr);
        logger.log("Rust Output:");
        logger.log(stderr);
        logger.log("/Rust Output:");
    }
    return JSON.parse(stdout);
}
async function getCargoWorkspaceRoot(cargoTomlPath, options) {
    const cargo = (await which_1.which("cargo")) || "cargo";
    const parentPath = path_1.default.dirname(cargoTomlPath);
    const safeParentPath = bash_1.escapeForBashSingleQuotes(parentPath);
    const safeCargoTomlPath = bash_1.escapeForBashSingleQuotes(cargoTomlPath);
    // TODO ENG-754: Rust currently doesn't work in sandbox mode.
    const { stdout } = await child_process_1.exec(`${cargo} metadata --format-version 1 --manifest-path '${safeCargoTomlPath}'`, {
        maxBuffer: 1024 * 8000,
        sandbox: options === null || options === void 0 ? void 0 : options.sandbox,
        mountReadOnlyDirectories: [...RUST_MOUNT_DIRECTORIES],
        mountReadWriteDirectories: [safeParentPath],
    });
    const metadata = JSON.parse(stdout);
    return metadata.workspace_root;
}
async function ensureRustDependencyToolInstalled() {
    // if (process.env["CODESEE_RUST_NO_INSTALL"]) {
    //   if (!(await canAccess(RUST_TOOL_PATH))) {
    //     throw new Error(
    //       `Unable to access ${RUST_TOOL_PATH} and CODESEE_RUST_ON_INSTALL is set `
    //     );
    //   } else {
    //     console.log(`CODESEE_RUST_NO_INSTALL set, using ${RUST_TOOL_PATH}`);
    //   }
    //   return;
    // }
    return helpers_1.ensureDependencyToolInstalled(langSpec.name, RUST_TOOL_BASE, RUST_TOOL_PATH, RUST_TOOL_URL, RUST_TOOL_TAR, RUST_TOOL_VERSION);
}
