"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilesToProcessFromFileChangeSet = exports.runForPackagesWithStrategy = exports.ensureDependencyToolInstalled = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("../../utils/fs");
const download_1 = require("../../utils/download");
const child_process_1 = require("../../utils/child_process");
const which_1 = require("../../utils/which");
const merge_1 = require("../merge");
const domain_core_1 = require("@codesee/domain-core");
async function ensureDependencyToolInstalled(language, toolBaseDir, toolPath, toolUrl, downloadedFilename, expectedVersion) {
    if (await fs_1.canAccess(toolPath)) {
        // This means that the tool is present, but that doesn't mean it's the right
        // version.
        const { stdout } = await child_process_1.exec(`${toolPath} --version`);
        if (stdout.includes(expectedVersion)) {
            return;
        }
        console.error(chalk_1.default.yellow(`Existing ${language} dependency tool is outdated. Upgrading tool.`));
    }
    console.error(chalk_1.default.whiteBright(`Installing ${language} dependency tool v${expectedVersion}...`));
    await fs_1.ensureDirExists(toolBaseDir);
    await download_1.downloadBinaryFile(toolUrl, downloadedFilename);
    const tar = await which_1.which("tar");
    await child_process_1.exec(`${tar} -C "${toolBaseDir}" -xvf "${downloadedFilename}"`);
    if (!(await fs_1.canAccess(toolPath))) {
        throw new Error(`Unable to install ${language} dependency tool, tool failed to install`);
    }
}
exports.ensureDependencyToolInstalled = ensureDependencyToolInstalled;
async function runForPackagesWithStrategy(repoRoot, allPackageNames, strategy, options) {
    if (allPackageNames.length === 0) {
        return { result: undefined, success: true };
    }
    try {
        await strategy.ensureToolInstalled();
    }
    catch (err) {
        console.error(chalk_1.default.red(`${strategy.language} tools failed to install: ${err.message}`));
        return { result: undefined, success: false };
    }
    const resultsSettled = await Promise.allSettled(allPackageNames.map((p) => strategy.runForPackage(repoRoot, p, allPackageNames, options)));
    let success = true;
    const results = resultsSettled
        .filter((r, index) => {
        if (r.status === "rejected") {
            console.error(chalk_1.default.yellow(`Unable to run for package ${allPackageNames[index]}: ${r.reason.message}`));
            success = false;
        }
        return r.status === "fulfilled";
    })
        // we need the any here because technically we have a PromiseFulfilledResult
        // type here because we are filtering out rejected promises in the filter
        // above.
        .map((r) => r.value);
    const result = merge_1.mergeResults(repoRoot, results);
    return { result, success };
}
exports.runForPackagesWithStrategy = runForPackagesWithStrategy;
/**
 * Given a file change set, compute the set of files that need
 * to be examined to determine the current state of the
 * repository. This is used in the process of generating an
 * incremental dependency map.
 *
 * @param {string} fileChangeSet - A string representation of the
 *   files that have been added, modified, renamed, or copied as
 *   generated by `git diff-index`.
 */
function getFilesToProcessFromFileChangeSet(fileChangeSet, includeDeleted = false) {
    const parsedFileChangeSet = domain_core_1.parseFileChangeSet(fileChangeSet);
    const res = new Set([
        // Process all new files
        ...parsedFileChangeSet.adds,
        // Process all changed files
        ...parsedFileChangeSet.modifications,
        // Process the new name for any renamed files
        ...parsedFileChangeSet.renames.map((migration) => migration.to),
        // Process both the original and the copy of a file
        ...parsedFileChangeSet.copies.flatMap((migration) => [
            migration.from,
            migration.to,
        ]),
    ]);
    if (includeDeleted) {
        parsedFileChangeSet.removes.forEach((f) => {
            res.add(f);
        });
        parsedFileChangeSet.renames.forEach((m) => {
            res.add(m.from);
        });
    }
    return res;
}
exports.getFilesToProcessFromFileChangeSet = getFilesToProcessFromFileChangeSet;
