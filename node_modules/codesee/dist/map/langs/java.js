"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const os_1 = require("os");
const domain_core_1 = require("@codesee/domain-core");
const fs_1 = require("../../utils/fs");
const download_1 = require("../../utils/download");
const constants_1 = require("../constants");
const git_1 = require("../git");
const child_process_1 = require("../../utils/child_process");
const which_1 = require("../../utils/which");
const merge_1 = require("../merge");
const promise_pool_1 = __importDefault(require("@supercharge/promise-pool"));
const bash_1 = require("../../utils/bash");
const helpers_1 = require("./helpers");
const langSpec = {
    name: "java",
    findPackagesFromFileList,
    runForPackages,
};
exports.default = langSpec;
const JAVA_TOOL_URL = "https://codesee-docs.s3.amazonaws.com/temp-dep-tools/codesee-deps-java-shadow.2.0.0.tar";
// TODO, should we update the JAVA_TOOL_BASE to avoid
// the rare edge case where ensureJavaDependencyToolInstalled
// exits early because it detects the previous version?
const JAVA_TOOL_BASE = path.join(os_1.tmpdir(), "codesee");
const JAVA_TOOL_PATH = path.join(JAVA_TOOL_BASE, "codesee-deps-java-shadow", "bin", "codesee-deps-java");
function isJavaBuildSystemFile(name) {
    return (name.endsWith("maven.config") ||
        name.endsWith("build.xml") || // TODO: Pass in JavaOptions so we can check ant build file names
        name.endsWith(".gradle") ||
        name.endsWith("gradlew") ||
        name.endsWith(".gradle.kts") ||
        name.endsWith("pom.xml"));
}
/**
 * hasAnyJavaBuildSystemFiles returns true if the input absolute
 * directory path contains any of Java build system files we know
 * about.
 *
 * @param {string} absoluteDirectoryPath - an absolute directory
 *   path.
 *
 * @returns {Promise<boolean>} true if the input directory contains at least
 *   one Java build system file.
 */
async function hasAnyJavaBuildSystemFiles(absoluteDirectoryPath) {
    const buildSystemFilenames = [
        "maven.config",
        "build.xml",
        ".gradle",
        "gradlew",
        ".gradle.kts",
        "pom.xml",
    ];
    const canAccessBuildSystemFiles = await Promise.all(buildSystemFilenames.map((filename) => {
        return fs_1.canAccess(path.join(absoluteDirectoryPath, filename));
    }));
    return canAccessBuildSystemFiles.some(Boolean);
}
/**
 * findNearestEnclosingPackageDirectories finds the "package"
 * directories on the path to the given absolute file path,
 * that is, every directory that contains a Java build system
 * file. This may include the same directory that the given
 * file is located in, as well as directories further up in
 * the directory tree.
 *
 * @param {string} absoluteRepoRoot - absolute path to repo root
 * @param {string} relativeFilePath - relative file path in repo
 *
 * @returns {Promise<string[]>} - list of package directories
 *   in the path to the given input file
 */
async function findEnclosingPackageDirectories(absoluteRepoRoot, relativeFilePath) {
    const res = [];
    const absoluteFilePath = path.resolve(absoluteRepoRoot, relativeFilePath);
    let directoryPath = path.dirname(absoluteFilePath);
    while (true) {
        if (await hasAnyJavaBuildSystemFiles(directoryPath)) {
            res.push(fs_1.ensureTrailingSlash(directoryPath));
        }
        if (fs_1.ensureTrailingSlash(directoryPath) === absoluteRepoRoot) {
            break;
        }
        const parts = directoryPath.split(path.sep);
        parts.pop();
        directoryPath = path.join(path.sep, ...parts);
    }
    return res;
}
/**
 * buildPackageNameMaps consumes a list of DomainCoreTypes.PackageNamePaths[],
 * the wire format for package name path data, and returns an object
 * containing two maps:
 *
 * Under the fileToPackageNameMap key is a Map that maps from relative
 * file paths like
 * "src/main/java/software/amazon/awssdk/utils/Logger.java"
 * to their associated Java package name, like
 * "software.amazon.awssdk.utils".
 *
 * Under the packageNameToFilesMap key is a Map from Java
 * package names like "software.amazon.awssdk.utils" to an
 * Array of .java files that comprise the package in question,
 * e.g. ["src/main/java/software/amazon/awssdk/utils/Logger.java"]
 * This is the inverse of the fileToPackageNameMap.
 *
 * These data structures are needed by the incremental maps
 * process to identify what package directories need to be
 * analyzed based on a change set.
 *
 * @param {DomainCoreTypes.PackageNamePath[]} packageNamePaths
 *
 * @returns {
 *   fileToPackageNameMap: Map<string, string>,
 *   packageNameToFilesMap: Map<string, string[]>
 * }
 */
function buildPackageNameMaps(packageNamePaths) {
    const fileToPackageNameMap = new Map();
    const packageNameToFilesMap = new Map();
    for (const [file, packageName] of packageNamePaths) {
        fileToPackageNameMap.set(file, packageName);
        const maybeFiles = packageNameToFilesMap.get(packageName);
        if (maybeFiles) {
            maybeFiles.push(file);
        }
        else {
            packageNameToFilesMap.set(packageName, [file]);
        }
    }
    return { fileToPackageNameMap, packageNameToFilesMap };
}
// There are some directories that we know will not have dependencies, so we
// filter them out using this function. Because it's used as a filter, pay attention
// that the entire conditional is `!(...)` so you should always use `||` to
// add additional directories to ignore.
function pathMightIncludeDependencies(p) {
    return !(p.endsWith("/gradle/") || p.endsWith("/buildSrc/"));
}
async function findPackagesFromFileList(repoRoot, files) {
    const packageNames = files
        .filter(isJavaBuildSystemFile)
        .map((p) => path.resolve(repoRoot, path.dirname(p)))
        .map((p) => fs_1.ensureTrailingSlash(p))
        .filter(pathMightIncludeDependencies);
    return [...new Set(packageNames)];
}
function supportsIncrementalMode(previousDependencyMapVersion, packageNamePathLanguages) {
    return Boolean(domain_core_1.versionMeetsOrExceedsMinimum(previousDependencyMapVersion, 4) && (packageNamePathLanguages === null || packageNamePathLanguages === void 0 ? void 0 : packageNamePathLanguages.java));
}
async function runForPackages(repoRoot, allPackageNames, options) {
    if (allPackageNames.length === 0) {
        return { result: undefined, success: true };
    }
    const javaOptions = options;
    if (javaOptions.mode === "incremental") {
        if (!supportsIncrementalMode(javaOptions.previousDependencyMapVersion, javaOptions.packageNamePathLanguages)) {
            console.log(chalk_1.default.yellowBright(`Previous dependency map does not have features needed to generate incremental dependency map for Java.\nGenerating full dependency map for Java files.`));
            javaOptions.mode = "full";
        }
    }
    try {
        await ensureJavaDependencyToolInstalled();
    }
    catch (err) {
        console.error(chalk_1.default.red(`Java tools failed to install: ${err.message}`));
        return { result: undefined, success: false };
    }
    let packagesToProcess = allPackageNames;
    if ((javaOptions === null || javaOptions === void 0 ? void 0 : javaOptions.mode) === "incremental") {
        // TODO ENG-829: Refactor this into a helper funciton.
        if (javaOptions.previousDependencyMapCommit &&
            javaOptions.fileChangeSet &&
            javaOptions.previousPackageNamePaths) {
            const filesToProcessSet = helpers_1.getFilesToProcessFromFileChangeSet(javaOptions.fileChangeSet);
            const { fileToPackageNameMap, packageNameToFilesMap } = buildPackageNameMaps(javaOptions.previousPackageNamePaths);
            const packagesToProcessSet = new Set();
            // Compute the list of package directories we need to analyze.
            for (const f of filesToProcessSet) {
                if (!f.endsWith(".java")) {
                    continue;
                }
                // Include the package directories in the path leading to
                // the current file that has a `.java` extension
                const packageDirectories = await findEnclosingPackageDirectories(repoRoot, f);
                packageDirectories.forEach((d) => {
                    packagesToProcessSet.add(d);
                });
                const packageName = fileToPackageNameMap.get(f);
                if (packageName) {
                    // The current file is part of a Java package
                    // that exists in a previous version of the repository.
                    const packageFiles = packageNameToFilesMap.get(packageName);
                    if (packageFiles) {
                        for (const additionalPackageFile of packageFiles) {
                            const packageDirectories = await findEnclosingPackageDirectories(repoRoot, additionalPackageFile);
                            // Include any other package directories that contain
                            // files that are part of the same package as the
                            // current file.
                            packageDirectories.forEach((d) => {
                                packagesToProcessSet.add(d);
                            });
                        }
                    }
                }
            }
            packagesToProcess = [...packagesToProcessSet];
        }
    }
    const { results, errors } = await promise_pool_1.default.for(packagesToProcess)
        .withConcurrency(2) // Java is a real processor hog.
        .process(async (p) => runForPackage(repoRoot, allPackageNames, p, javaOptions));
    errors.forEach((err) => {
        console.error(chalk_1.default.yellow(`Java tools failed to run for package ${err}`));
    });
    results.sort((a, b) => (a.packageName || "").localeCompare(b.packageName || ""));
    const result = merge_1.mergeResults(repoRoot, results, {
        useFileToFullPackageMap: true,
        linksAreAbsolute: true,
        omitPackageName: true,
    });
    if (result && (javaOptions === null || javaOptions === void 0 ? void 0 : javaOptions.mode) === "full") {
        result.linkLanguages.java = true;
        result.packageNamePathLanguages.java = true;
    }
    return { result, success: errors.length === 0 };
}
async function runForPackage(repoRoot, packageNames, packageDir, options) {
    const promises = await Promise.all([
        git_1.enumerateFiles(repoRoot, packageDir, constants_1.exclusions, packageNames),
        runJavaDeps(packageDir, options),
    ]);
    const results = {
        version: constants_1.fileFormatVersion4,
        mode: (options === null || options === void 0 ? void 0 : options.mode) || "full",
        linkLanguages: {},
        packageNamePathLanguages: {},
        packageName: path.basename(packageDir),
        packageDirectory: packageDir.replace(repoRoot, ""),
        packageNamePaths: promises[1].packageNamePaths,
        commitHash: "",
        previousDependencyMapCommit: options === null || options === void 0 ? void 0 : options.previousDependencyMapCommit,
        fileChangeSet: options === null || options === void 0 ? void 0 : options.fileChangeSet,
        configuration: "",
        nodes: promises[0].map((n) => ({ key: n })),
        links: promises[1].links,
    };
    if (results.links.length === 0) {
        console.error(chalk_1.default.yellow(`No links found for ${packageDir}`));
    }
    if (results.nodes && results.nodes.length > 0) {
        return results;
    }
    else {
        throw new Error(`Invalid package "${packageDir}". Skipping.`);
    }
}
async function runJavaDeps(packageRoot, options) {
    // The environment variable is used for development only,
    // no need to set this anywhere but in development
    const toolPath = process.env.CODESEE_JAVA_DEPS_PATH || JAVA_TOOL_PATH;
    const safepackageRoot = bash_1.escapeForBashSingleQuotes(packageRoot);
    const { stdout, stderr } = await child_process_1.exec(`${toolPath} '${safepackageRoot}'`, {
        // ~4MB of output buffer, spring is around 2MBs
        maxBuffer: 1024 * 40000,
        env: {
            HOME: process.env.HOME,
            PATH: process.env.PATH,
            // The default java opts on github is 1GB, but that's not
            // enough to run against large repos, so make it 8GBs which
            // seems to work fine.
            CODESEE_DEPS_JAVA_OPTS: "-Xmx8196m",
        },
        sandbox: options.sandbox,
        mountReadOnlyDirectories: [
            JAVA_TOOL_BASE,
            toolPath,
            safepackageRoot,
            // When running in sandbox mode, java needs to be installed in this
            // directory.
            "/usr/local/java",
        ],
        maxMemoryMB: 16 * 1024,
        quiet: true,
    });
    if (stderr.length > 0) {
        throw new Error(`Java deps failed:
stdout: "${stdout}"
stderr: "${stderr}"`);
    }
    return JSON.parse(stdout);
}
async function ensureJavaDependencyToolInstalled() {
    if (await fs_1.canAccess(JAVA_TOOL_PATH)) {
        return;
    }
    console.error(chalk_1.default.whiteBright(`Installing Java dependency tool...`));
    await fs_1.ensureDirExists(JAVA_TOOL_BASE);
    console.error(chalk_1.default.whiteBright(`\tDownloading`));
    await download_1.downloadBinaryFile(JAVA_TOOL_URL, path.join(JAVA_TOOL_BASE, "codesee-deps-java-shadow.2.0.0.tar"));
    console.error(chalk_1.default.whiteBright(`\tUntaring`));
    const tar = await which_1.which("tar");
    await child_process_1.exec(`${tar} -C "${JAVA_TOOL_BASE}" -xvf "${JAVA_TOOL_BASE}/codesee-deps-java-shadow.2.0.0.tar"`);
    console.error(chalk_1.default.whiteBright(`\tVerifying`));
    if (!(await fs_1.canAccess(JAVA_TOOL_PATH))) {
        throw new Error(`Unable to install Java dependency tool, tool failed to install`);
    }
}
