"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stashPop = exports.stashSave = exports.enumeratePackages = exports.enumerateFiles = exports.runLsTreeForPackage = void 0;
const micromatch_1 = __importDefault(require("micromatch"));
const constants_1 = require("./constants");
const bash_1 = require("../utils/bash");
const git_1 = require("../utils/git");
const domain_core_1 = require("@codesee/domain-core");
/**
 * It is very unclear what this function does. We're doing a "not every", which
 * means "some or none", which doesn't seem useful. This returns true if the
 * module name matches some or none of the passed in package names. So it will
 * only return false if allPackages is empty or it only contains a single
 * package that matches the module name in the file path.
 *
 * Some examples of how it works:
 * - Where `filePath` is under a local package.
 *   - **filePath**: `packages/server/node_modules/@codesee/domain-core/index.js`
 *   - **ofInterest**: `@codesee/domain-core/index.js`
 *   - **allPackages**: [`@codesee/server`, `@codesee/domain-core`]
 *   - **Returns**: `true`
 * - Where `filePath` is _not_ under a local package.
 *   - **filePath**: `packages/server/node_modules/foo/index.js`
 *   - **ofInterest**: `foo/index.js`
 *   - **allPackages**: [`@codesee/server`, `@codesee/domain-core`]
 *   - **Returns**: `true`
 *
 * If you know how this function is supposed to work, please update this comment
 * to be the correct functionality!
 *
 * @param filePath
 * @param allPackages
 * @returns
 */
function refersTo(filePath, allPackages) {
    const ofInterest = filePath.split("node_modules/", 2)[1];
    return !allPackages.every((pkg) => ofInterest.startsWith(pkg));
}
/**
 * This lists all the files of the repo according to git. This will only include
 * entries for files, not directories, so if you need that, use
 * `createSetWithFilesAndDirectories`.
 *
 * Because this is based off a git command, it will respect the .gitignore file.
 * It also doesn't include any untracked files since it bases it off the latest
 * commit.
 *
 * This is the canonical list of files that are expected to be in the nodes
 * array of a dependency map. When in doubt, compare the nodes against the list
 * of files returned from this function.
 *
 * @param repoRoot The root of the repo.
 * @param packageDir The directory within the repo we want to enumerate.
 * @returns The canonical list of files that we should be including in a
 * dependency map.
 */
async function runLsTreeForPackage(repoRoot, packageDir) {
    const safePackageDir = bash_1.escapeForBashSingleQuotes(packageDir);
    const results = await git_1.execGit(repoRoot, "-c", "core.quotepath=off", "ls-tree", "-r", "HEAD", "--name-only", `'${safePackageDir}'`);
    const fileList = results.split("\n").filter((p) => p !== "");
    const decodedFileList = fileList.map((filepath) => domain_core_1.normalizeFilename(filepath));
    return decodedFileList;
}
exports.runLsTreeForPackage = runLsTreeForPackage;
/**
 * This is very similar to `runLsTreeForPackage`, but filters out node_modules
 * along with any other given exclusions. This is meant to be used as the list
 * of files that we want to process links for (since we don't want to generate
 * links for any node_modules that are checked into the repo).
 *
 * This is _not_ all of the files that should be included in the nodes array of
 * a dependency map. Use `runLsTreeForPackage` for that list of files.
 *
 * @param repoRoot The root of the repo.
 * @param packageDir The directory within the repo we want to enumerate.
 * @param exclusions Array of glob patterns to match. For example, if you wanted
 * to exclude files in the vendor directory, you would pass in "vendor/*".
 * @param allPackageNames Array of package names.
 * @returns The list of files that we should be processing links for.
 */
async function enumerateFiles(repoRoot, packageDir, exclusions, allPackageNames) {
    const files = await runLsTreeForPackage(repoRoot, packageDir);
    return (files
        // It's unclear what this filter does. See the comment for refersTo.
        .filter((p) => !p.includes("node_modules/") || refersTo(p, allPackageNames))
        // Filter out any files that match any of the exclusion globs.
        .filter((p) => micromatch_1.default([p], exclusions, constants_1.matchConfig).length === 0));
}
exports.enumerateFiles = enumerateFiles;
async function enumeratePackages(langs, repoRoot, files, options) {
    const packages = {};
    for (const langSpec of langs) {
        packages[langSpec.name] = await langSpec.findPackagesFromFileList(repoRoot, files, options);
    }
    return packages;
}
exports.enumeratePackages = enumeratePackages;
async function stashSave(repoRoot) {
    await git_1.execGit(repoRoot, "stash", "save");
}
exports.stashSave = stashSave;
async function stashPop(repoRoot) {
    await git_1.execGit(repoRoot, "stash", "pop");
}
exports.stashPop = stashPop;
