"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remapNameToDirectory = exports.mergeResults = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const fs_1 = require("../utils/fs");
const constants_1 = require("./constants");
const groups_1 = require("./groups");
/**
 * mergeResults merges a collection of 1 or more
 * `MergeResultV4` objects. It is the last step in
 * the sequence for aggregating dependencies for each
 * individual language.
 *
 * At the time of this writing, this `mergeResults`
 * implementation was used to handle merging results
 * for Java, Go, and Rust. Python has its own
 * implementation also named `mergeResults`, and
 * JavaScript's implementation is called
 * `mergeJavascriptResults`.
 *
 * TODO ENG-735: Can we unify our `mergeResults`
 * implementations?
 *
 *
 * @param {string} repoRoot absolute path to repository root
 * @param {MergeResultV4[]} unmerged unmerged results
 * @param {MergeResultsOptions} options
 * @param {boolean} options.useFileToFullPackageMap indicates
 *   whether or not to use the fileToFullPackageMap as the
 *   basis of the `packageNamePaths` entry in the final result.
 * @param {boolean} options.linksAreAbsolute if true, this
 *   indicates that links should deep link to individual
 *   files within a module, and not to a top-level module.
 *   This is needed for Java where links are always absolute.
 * @param {boolean} options.omitPackageName if true, values
 *   in the nodes array of the final result will omit the
 *   `packageName` key. We believe this key is no longer used,
 *   and it's definitely not used for Java.
 *
 * @returns {MergeResultV4 | undefined} the unmerged inputs
 *   merged into a single `MergeResultV4` object.
 */
function mergeResults(repoRoot, unmerged, options = {
    useFileToFullPackageMap: false,
    linksAreAbsolute: false,
    omitPackageName: false,
}) {
    if (unmerged.length === 0) {
        return undefined;
    }
    repoRoot = path.resolve(repoRoot);
    const { directoryToShortPackageMap, fileToFullPackageMap } = createPackageMap(repoRoot, unmerged);
    const linkLanguages = unmerged.reduce((languages, results) => {
        return { ...languages, ...results.linkLanguages };
    }, {});
    const packageNamePathLanguages = unmerged.reduce((languages, results) => {
        return { ...languages, ...results.packageNamePathLanguages };
    }, {});
    let packageNamePaths = unmerged.length === 1 ? [] : [...directoryToShortPackageMap];
    if (options.useFileToFullPackageMap) {
        packageNamePaths = [...fileToFullPackageMap];
    }
    const results = {
        version: constants_1.fileFormatVersion4,
        mode: unmerged[0].mode,
        linkLanguages,
        packageNamePathLanguages,
        commitHash: unmerged[0].commitHash,
        previousDependencyMapCommit: unmerged[0].previousDependencyMapCommit,
        fileChangeSet: unmerged[0].fileChangeSet,
        packageName: unmerged.length === 1 ? unmerged[0].packageName : undefined,
        packageNamePaths,
        nodes: [],
        links: [],
    };
    results.nodes = combineNodes(directoryToShortPackageMap, unmerged.flatMap((r) => r.nodes), options);
    groups_1.generateMissingGroups(results.nodes);
    results.links = combineLinks(repoRoot, directoryToShortPackageMap, unmerged, options);
    return results;
}
exports.mergeResults = mergeResults;
/**
 * createPackageMap returns a CreatePackageMapResult
 * that exposes two PackageMap objects.
 *
 * The map associated with the `directoryToShortPackageMap`
 * key is the one this function originally generated. It
 * maps from mergeResult.packageDirectory to
 * mergeResult.packageName. It may not actually be used,
 * but some downstream code seems to depend on it so,
 * for now, I'm returning it and passing it to the
 * downstream code.
 *
 * TODO ENG-734: See if we can eliminate the
 * `directoryToShortPackageMap` from the return value of
 * this.
 *
 * The map associated with the `fileToFullPackageMap` maps
 * from a complete relative file path within the repo to
 * the the full package name the file is a part of. Note
 * this map will only be properly populated if the input
 * `unmerged` merge results contain the necessary data in
 * mergeResult.packageNamePaths. At the time of this
 * writing Java is the language that is guaranteed to do
 * this. Note for Java, the key will be a file path, and
 * the full package name will be a Java package name
 * separated by dots, e.g.
 * `software.amazon.awssdk.protocols.core`
 *
 * @param {string} repoRoot absolute path to repository root
 * @param {MergeResultV4[]} unmerged unmerged results
 *
 * @returns {CreatePackageMapResult}
 */
function createPackageMap(repoRoot, unmerged) {
    const directoryShortPackagePairs = [];
    const fileFullPackagePairs = [];
    unmerged.forEach((mergeResult) => {
        const packageNamePaths = mergeResult.packageNamePaths || [];
        const currentResultFilePackagePairs = packageNamePaths.map(([file, packageName]) => {
            return [
                cleanPath(fs_1.ensureTrailingSlash(repoRoot), mergeResult.packageDirectory, file),
                packageName,
            ];
        });
        fileFullPackagePairs.push(...currentResultFilePackagePairs);
        directoryShortPackagePairs.push([
            fs_1.ensureTrailingSlash(mergeResult.packageDirectory || ""),
            mergeResult.packageName || "",
        ]);
    });
    const directoryToShortPackageMap = new Map(directoryShortPackagePairs);
    const fileToFullPackageMap = new Map(fileFullPackagePairs);
    return { directoryToShortPackageMap, fileToFullPackageMap };
}
function getKeyPackageAndGroup(packageDirToNameMap, filePath) {
    // We need to standardize on whether this is a relative path or an absolute path.
    // We pick relative because it should be relative to the repo root, but
    // path.resolve will resolve as an absolute path, so we need to munge it
    // a bit to make sure it's consistent.
    if (filePath[0] === "/") {
        filePath = filePath.substr(1);
    }
    const group = fs_1.dirnameOrUndefined(filePath);
    // We sort reverse order by length (longest ones first) so that we avoid the problem
    // where we remove the parent directory from the filePath for a child package.
    // e.g. /package1/package2 where /package1 is a package and /package1/package2 is also a package
    const packageRelPaths = [...packageDirToNameMap.keys()].sort((a, b) => b.length - a.length);
    for (const packageRelPath of packageRelPaths) {
        if (filePath.startsWith(packageRelPath)) {
            // TODO: this isn't quite right.
            return {
                key: filePath,
                group,
                packageName: packageDirToNameMap.get(packageRelPath),
                packagePath: packageRelPath,
            };
        }
    }
    return {
        key: filePath,
        group,
    };
}
function combineNodes(packageDirToNameMap, nodes, options) {
    const { omitPackageName } = options;
    const newNodes = nodes
        .map((res) => getKeyPackageAndGroup(packageDirToNameMap, res.key))
        .map((res) => {
        delete res.packagePath;
        if (omitPackageName) {
            delete res.packageName;
        }
        return res;
    })
        .filter((res) => res.key !== ""); // Filter out empty keys.
    // This is used to dedupe based on key value and then we return the filtered
    // nodes. This is necessary because the file viewer will show duplicate nodes,
    // but GoJS actually prunes the duplicate nodes while rendering. :shrug:
    const nodeKeys = new Set();
    return newNodes.filter((n) => {
        if (nodeKeys.has(n.key))
            return false;
        nodeKeys.add(n.key);
        return true;
    });
}
/**
 * cleanPath cleans up input path by first constructing
 * an absolute path, concatenating repoRoot, packageDirectory,
 * and inputPath, and then strips the repoRoot prefix to
 * produce a path that is relative to the repository root.
 *
 * @param {string} repoRoot absolute path to repository root
 * @param {string | undefined} packageDirectory relative path
 *   below `repoRoot` where inputPath is located under
 * @param inputPath relative path under `packageDirectory` to
 *   file
 *
 * @returns {string} complete path to specified file relative
 *   to the repository root.
 */
function cleanPath(repoRoot, packageDirectory, inputPath) {
    const packageDir = packageDirectory || "";
    return path.resolve(repoRoot, packageDir, inputPath).replace(repoRoot, "");
}
const makeLinksFullPaths = (repoRoot) => (p) => {
    const packageDir = p.packageDirectory || "";
    return p.links.map(({ to, from }) => {
        return [
            cleanPath(repoRoot, packageDir, to),
            cleanPath(repoRoot, packageDir, from),
        ];
    });
};
const getLinkPackageAndGroup = (packageDirToNameMap) => ([to, from]) => {
    return {
        to: getKeyPackageAndGroup(packageDirToNameMap, to),
        from: getKeyPackageAndGroup(packageDirToNameMap, from),
    };
};
const detectLinkDuplication = (linkIds) => ({ to, from }) => {
    const key = `${to}|${from}`;
    if (linkIds.has(key)) {
        return false;
    }
    linkIds.add(key);
    return true;
};
// When linking across modules, we want to link to just the module name, not the internal file that may
// have been specifically linked to because most of the time it'll either be a compiled version or just `index.js` so
// it looks messier than if we just link to the module name.
//
// At this point, `from` is formatted like `<package name>:<file path>`. `to` may or may not be in that form depending on
// if it refers to one of the internal packages.
const cleanCrossModuleLinks = ({ to, from }) => {
    const fromPackage = from.packagePath;
    const toPackage = to.packagePath;
    // Check to see if we are refering to the same package
    if (!fromPackage || !toPackage || fromPackage === toPackage) {
        // If we are, do nothing
        return { to: to.key, from: from.key };
    }
    else {
        // Otherwise, do the substitution
        return { to: toPackage, from: from.key };
    }
};
function combineLinks(repoRoot, packageDirToNameMap, unmerged, options) {
    const { linksAreAbsolute } = options;
    const linkIds = new Set();
    const linkTuplesWithFullPaths = unmerged.flatMap(makeLinksFullPaths(repoRoot));
    const linksWithGroupAndPackage = linkTuplesWithFullPaths.map(getLinkPackageAndGroup(packageDirToNameMap));
    let links = [];
    if (linksAreAbsolute) {
        links = linksWithGroupAndPackage.map((l) => {
            return { to: l.to.key, from: l.from.key };
        });
    }
    else {
        links = linksWithGroupAndPackage.map(cleanCrossModuleLinks);
    }
    links = links.map(({ to, from }) => ({
        to: stripTrailingSlash(to),
        from: stripTrailingSlash(from),
    }));
    // We used to filter links with a helper named
    // linkConnectsTwoNodes nodes here. This was fine when
    // generating a full map, but might cause issues with
    // incremental maps if the node target was not modified
    // in the changeset. This is no longer needed because
    // `pruneNonExistentEntries` in `map/index.ts`
    // accomplishes the same goal in a more robust manner.
    links = links.filter(detectLinkDuplication(linkIds));
    return links;
}
function stripTrailingSlash(s) {
    if (s[s.length - 1] === "/") {
        s = s.substr(0, s.length - 1);
    }
    return s;
}
// TODO ENG-733: See if this can be removed, and do so.
function remapNameToDirectory(path, packageNameDirMap) {
    // If We don't have a package name prefix, just return the path.
    if (!path.includes(":")) {
        return path;
    }
    const packageName = path.split(":")[0];
    if (!packageName) {
        // Fail-safe, but we should never hit this because the only way it could fail is
        // if the above if statement is somehow bypassed, but we can't find the ":"
        console.error(chalk_1.default.redBright(`${path} had a ":" but couldn't split. Something really wrong happened`));
        return path;
    }
    let dirName = packageNameDirMap.get(packageName);
    if (!dirName) {
        console.error(chalk_1.default.yellow(`Found ${path} (${packageName}) with package prefix, but no mapping found`));
        return path;
    }
    if (!dirName.endsWith("/")) {
        dirName += "/";
    }
    return path.replace(`${packageName}:`, dirName);
}
exports.remapNameToDirectory = remapNameToDirectory;
