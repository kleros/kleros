"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFile = exports.renderHandlebars = exports.readFile = exports.projectPackageJson = exports.installPackages = exports.formatList = void 0;
const fs = __importStar(require("fs"));
const handlebars_1 = __importDefault(require("handlebars"));
const path = __importStar(require("path"));
const process_1 = __importDefault(require("process"));
const child_process_1 = require("child_process");
/**
 * Asynchronously checks if a file exists.
 * @param {string} filePath - The path you want to check.
 * @returns {Promise<boolean>} A boolean indicating if the file exists or not.
 */
function fileExists(filePath) {
    return new Promise((resolve, reject) => {
        fs.stat(filePath, (err) => {
            if (!err) {
                return resolve(true);
            }
            // File not found
            if (err.code === "ENOENT") {
                return resolve(false);
            }
            // Other error
            return reject(err);
        });
    });
}
/**
 * Formats an array of strings into a single string using proper grammar.
 * @param {Array<string>} list - The array of strings you want to format.
 * @returns {string} The elements of the list joined together using proper
 * grammar.
 */
function formatList(list) {
    switch (list.length) {
        case 0:
            return "";
        case 1:
            return `${list[0]}`;
        case 2:
            return list.join(" and ");
        default:
            return `${list.slice(0, -1).join(", ")}, and ${list[list.length - 1]}`;
    }
}
exports.formatList = formatList;
/**
 * Asynchronously installs packages either using yarn or npm, depending on the
 * existence of a yarn.lock.
 * @param {Array<string>} pkgs - The packages that you want to install.
 * @param {Object} options - Any options to configure the installation.
 * @param {boolean} options.dev - Whether the packages should be installed as
 * dev dependencies.
 * @returns {Promise<void>}
 */
async function installPackages(pkgs, options = {}) {
    const yarnLockFilePath = path.join(process_1.default.cwd(), "yarn.lock");
    const useYarn = await fileExists(yarnLockFilePath);
    let command;
    let args;
    if (useYarn) {
        command = "yarn";
        args = ["add"];
        if (options.dev) {
            args.push("--dev");
        }
        args = args.concat(pkgs);
    }
    else {
        command = "npm";
        args = ["install"];
        if (options.dev) {
            args.push("--save-dev");
        }
        args = args.concat(pkgs);
    }
    return new Promise((resolve, reject) => {
        const child = child_process_1.spawn(command, args, { stdio: "inherit" });
        child.on("close", (code) => {
            if (code !== 0) {
                return reject(new Error("Error installing packages."));
            }
            resolve();
        });
    });
}
exports.installPackages = installPackages;
/**
 * Asynchronously parses the contents of the project's package.json.
 * @returns {Promise<Object>} The parsed contents of the package.json.
 */
async function projectPackageJson() {
    const filePath = path.join(process_1.default.cwd(), "package.json");
    const exists = await fileExists(filePath);
    if (exists) {
        // Note: Even though this is a JSON file, we can't use require to
        // automatically parse the file because require caches files, and we need to
        // make sure each time we read this file, it's up-to-date.
        const data = await readFile(filePath);
        return JSON.parse(data);
    }
    throw new Error("package.json doesn't exist in current directory. Make sure you're in the root of your project.");
}
exports.projectPackageJson = projectPackageJson;
/**
 * Asynchronously reads the contents of a file.
 * @param {string} filePath - The path of the file you want to read.
 * @returns {Promise<string>} The contents of the file as a string.
 */
async function readFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, { encoding: "utf-8" }, (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data.toString());
        });
    });
}
exports.readFile = readFile;
/**
 * Asynchronously renders templates that live in src/templates using Handlebars.
 * @param {string} templateFileName - The name of the file that resides in
 * src/templates containing the template you want to render.
 * @param {Object} data - The data that will be used when rendering the
 * template.
 * @returns {Promise<string>} The rendered template.
 */
async function renderHandlebars(templateFileName, data) {
    const resolvedFilePath = path.resolve(__dirname, "templates", templateFileName);
    const contents = await new Promise((resolve, reject) => {
        fs.readFile(resolvedFilePath, (err, buffer) => {
            if (err) {
                return reject(err);
            }
            resolve(buffer.toString());
        });
    });
    const template = handlebars_1.default.compile(contents);
    return template(data);
}
exports.renderHandlebars = renderHandlebars;
/**
 * Asynchronously writes the contents to a file.
 * @param {string} filePath - The path of the file you want to write.
 * @param {string} contents - The contents that you want to write to the file.
 * @returns {Promise<void>}
 */
function writeFile(filePath, contents) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, contents, (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}
exports.writeFile = writeFile;
