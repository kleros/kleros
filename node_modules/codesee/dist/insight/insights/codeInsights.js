"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_constants_1 = require("@codesee/shared-constants");
const bash_1 = require("../../utils/bash");
const child_process_1 = require("../../utils/child_process");
const mapping = [
    [shared_constants_1.INSIGHTS.LINES_OF_CODE, getLinesOfCode],
];
exports.default = mapping;
const EXTENSION_IGNORE_SET = [
    ".lock",
    ".snap",
    ".txt",
    ".yaml",
    ".yml",
    ".json",
    ".md",
];
function shouldIgnore(filename) {
    for (const ext of EXTENSION_IGNORE_SET) {
        if (filename.endsWith(ext)) {
            return true;
        }
    }
    return false;
}
async function getLinesOfCode(filePath, { lineCounter, binaryDetector }) {
    if (shouldIgnore(filePath)) {
        return Number.NaN;
    }
    const safeFilePath = bash_1.escapeForBashSingleQuotes(filePath);
    if (binaryDetector !== undefined) {
        const { stdout: fileTypeOutput } = await child_process_1.exec(`${binaryDetector} '${safeFilePath}'`);
        if (fileTypeOutput.trim() === "binary") {
            return Number.NaN;
        }
    }
    const { stdout } = await child_process_1.exec(`${lineCounter} '${safeFilePath}'`);
    // We are taking advantage of the way parseInt works. It parses (ignore leading whitespace) a number up to the
    // first non-numerical character and returns the number that has been parsed so far.
    // Since our output is in the form "     DDD filename", parseInt will parse out the "DDD"
    const count = parseInt(stdout);
    return count;
}
