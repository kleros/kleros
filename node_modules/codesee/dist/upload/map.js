"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const axios_1 = __importDefault(require("axios"));
const fs_1 = require("fs");
const fs_2 = require("../utils/fs");
const git_1 = require("../utils/git");
exports.default = () => ["map", handler];
async function handler(dataFile, apiToken, serverUrl, opts) {
    if (!opts.repo)
        throw new Error("--repo is required for the map data type");
    if (opts.pullRequestNumber !== undefined && opts.baseCommitHash === undefined)
        throw new Error("--baseCommitHash is required when specifying --pullRequestNumber");
    const accessible = await fs_2.canAccess(dataFile);
    if (!accessible) {
        console.warn(chalk_1.default.yellow(`Aborting upload. Cannot find or access map output at ${dataFile}`));
        return;
    }
    const remote = git_1.getBaseRemote();
    // TODO: Use Promise.all to run these in parallel
    const fileChangeSets = [];
    if (opts.pullRequestNumber === undefined) {
        const snapshotsMeta = await fetchMetaOnLatestSnapshots(apiToken, serverUrl, opts.repo);
        for (const meta of snapshotsMeta) {
            const fileChangeSet = await git_1.determineFileChangeSet(remote, meta.gitCommit);
            fileChangeSets.push({
                ...meta,
                fileChangeSet,
            });
        }
    }
    else {
        // at this point because of the preconditions above, we know that baseCommitHash is defined
        const rootCommit = await findCommonRoot(remote, opts.baseCommitHash, opts.ref);
        if (!rootCommit) {
            throw new Error(`Unable to find parent commit between ${opts.baseCommitHash} and ${opts.ref}`);
        }
        const fileChangeSet = await git_1.determineFileChangeSet(remote, rootCommit);
        fileChangeSets.push({
            diagramId: null,
            iteration: null,
            pullRequestNumber: opts.pullRequestNumber,
            gitCommit: opts.baseCommitHash,
            fileChangeSet,
        });
    }
    await uploadMapToServer(dataFile, fileChangeSets, apiToken, serverUrl, opts);
}
async function findCommonRoot(remote, baseCommit, headCommit) {
    const repoRoot = await git_1.checkAccessAndDetermineRepoRoot();
    if (!repoRoot) {
        return null;
    }
    // This will only be defined on a pull request.
    const baseRef = process.env.GITHUB_BASE_REF;
    if (baseRef) {
        // CODESEE-2583: For forked repositories, we may not have the
        // necessary commits from the base repository so fetch them
        // before we run merge-base.
        await git_1.safeFetch(repoRoot, remote, baseRef);
    }
    // The output of merge-base is a single line output with the commit hash.
    // We split on the new line that will exist at the end, and take the first element of the
    // results which will be the SHA without the new line.
    const root = (await git_1.execGit(repoRoot, "merge-base", baseCommit, headCommit)).split("\n")[0];
    return root;
}
async function fetchMetaOnLatestSnapshots(apiToken, serverUrl, repoOrigin) {
    console.log(chalk_1.default.white(`Fetching current git commit for each diagram snapshot`));
    if (!repoOrigin.startsWith("https://github.com/")) {
        console.log(`\n${chalk_1.default.red(`Unable to determine repo name from ${repoOrigin}`)}`);
        return [];
    }
    const repoName = repoOrigin.substring("https://github.com/".length);
    // Note: we must use encodeURIComponent here so that the forward slash in repoName is URI encoded
    const endpoint = `${serverUrl}/api/maps/repos/${encodeURIComponent(repoName)}/snapshot_metadata`;
    const headers = {
        Authorization: `Bearer ${apiToken}`,
    };
    let result;
    try {
        // by default axios throws on non 2xx results
        result = await axios_1.default({
            url: endpoint,
            method: "GET",
            headers,
            withCredentials: true,
        });
    }
    catch (err) {
        if (axios_1.default.isAxiosError(err) &&
            err.response &&
            err.response.status === 404) {
            return [];
        }
        else {
            throw err;
        }
    }
    const diagrams = result.data.diagrams;
    console.log(chalk_1.default.whiteBright("Fetched successfully: " + diagrams.length + " diagrams on this repo."));
    return diagrams;
}
async function uploadMapToServer(dataFile, fileChangeSets, apiToken, serverUrl, opts) {
    console.log(`${chalk_1.default.white(`Uploading to ${serverUrl}`)}`);
    const mapBuffer = await fs_1.promises.readFile(dataFile);
    const mapData = JSON.parse(mapBuffer.toString());
    const endpoint = `${serverUrl}/api/maps/dependency-map/new`;
    const headRef = getBranchName(opts.ref);
    const baseRef = getBranchName(opts.baseRef);
    const body = {
        mapData,
        fileChangeSets,
        repoOrigin: opts.repo,
        ref: headRef || undefined,
        baseRef,
        pullRequestNumber: opts.pullRequestNumber,
        baseCommit: opts.baseCommitHash,
        gitCommit: mapData.commitHash,
        runnerType: opts.runner,
        configuration: mapData.configuration,
    };
    const headers = {
        Authorization: `Bearer ${apiToken}`,
    };
    // by default axios throws on non 2xx results
    await axios_1.default({
        url: endpoint,
        method: "POST",
        data: body,
        headers,
        withCredentials: true,
    });
    console.log(`${chalk_1.default.whiteBright("Uploaded successfully")}`);
}
/**
 * Given undefined or a string containing either a bare branch
 * name or a a refs/heads/main or refs/tags/v0.60.0 returns the
 * bare branch or tag name if the input was not undefined.
 * @param {string|undefined} maybeRef
 */
function getBranchName(maybeRef) {
    let branchName = maybeRef;
    if (maybeRef && maybeRef.startsWith("refs/heads/")) {
        branchName = maybeRef.substring("refs/heads/".length);
    }
    else if (maybeRef && maybeRef.startsWith("refs/tags/")) {
        branchName = maybeRef.substring("refs/tags/".length);
    }
    return branchName;
}
