"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runDiffIndex = exports.safeFetch = exports.determineFileChangeSet = exports.checkAccessAndDetermineRepoRoot = exports.getCommitHash = exports.execGit = exports.determineRepoRoot = exports.getBaseRemote = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("./fs");
const path = __importStar(require("path"));
const which_1 = require("./which");
const child_process_1 = require("./child_process");
/**
 * getBaseRemote returns either the url of the base repository's
 * origin when we are running on a pull request, or the string
 * "origin". Either is suitable for the first parameter that
 * specifies a remote when calling `git fetch`.
 *
 * @returns {string} specifying the desired remote when calling `git fetch`
 */
function getBaseRemote() {
    // Typically https://github.com
    const serverUrl = process.env.GITHUB_SERVER_URL;
    // The owner and repository name of the base repository, e.g. Codesee-io/codesee
    const baseRepository = process.env.GITHUB_REPOSITORY;
    // Target branch of a pull request, only set for pull requests, e.g. main
    const baseRef = process.env.GITHUB_BASE_REF;
    if (serverUrl && baseRepository && baseRef) {
        // If all three of the values above are defined, we're running
        // on a pull request. Compute the url for the remote. If the
        // pull request is on a fork of a repository, this will be the
        // *base* repository's origin. If this is not a fork, we're
        // just being a little more explicit
        return `${serverUrl}/${baseRepository}.git`;
    }
    return "origin";
}
exports.getBaseRemote = getBaseRemote;
async function determineRepoRoot(baseDir) {
    let repoRoot = baseDir;
    // If we aren't already at the root of the repository, determine the root of
    // the repository.
    if (!(await checkIsRepoRoot(repoRoot))) {
        repoRoot = await getRepoRootAccordingToGit(repoRoot);
    }
    // `git rev-parse --show-toplevel` will return different results depending on
    // how it is invoked. We never want to start with a relative path so we resolve
    // the path based on the current working directory which will give us an
    // absolute path.
    repoRoot = path.resolve(process.cwd(), repoRoot);
    repoRoot = fs_1.ensureTrailingSlash(repoRoot);
    return repoRoot;
}
exports.determineRepoRoot = determineRepoRoot;
function isQuote(x) {
    return x === '"' || x === "'";
}
/**
 * If the string x begins and ends with either single or
 * double quotes, just return the string, otherwise, wrap
 * them in double quotes.
 */
function quoteIfNecessary(x) {
    if (!x)
        return "";
    if (x.length > 0 && !isQuote(x[0]) && !isQuote(x[x.length - 1])) {
        return `"${x}"`;
    }
    return x;
}
async function execGit(repoRoot, ...args) {
    const git = await which_1.which("git");
    const commandLine = [git, ...args].map(quoteIfNecessary).join(" ");
    const { stdout } = await child_process_1.exec(commandLine, {
        cwd: repoRoot,
        maxBuffer: 40 * 1024 * 1024,
    });
    return stdout.trim();
}
exports.execGit = execGit;
async function getCommitHash(repoRoot) {
    return await execGit(repoRoot, "rev-parse", "HEAD");
}
exports.getCommitHash = getCommitHash;
async function checkIsRepoRoot(potentialRepoRoot) {
    const path = await execGit(potentialRepoRoot, "rev-parse", "HEAD");
    // It's the repo root if this command returns just ".git".
    return /^\.(git)?$/.test(path.trim());
}
async function getRepoRootAccordingToGit(directory) {
    return await execGit(directory, "rev-parse", "--show-toplevel");
}
/**
 * checkAccessAndDetermineRepoRoot returns a promise to the repo root
 * or null
 *
 * @returns {Promise<string | null>}
 */
async function checkAccessAndDetermineRepoRoot() {
    const repoDir = await fs_1.getCurrentDirectory();
    // Check that the directory that was passed in exists.
    // This only checks the existence. If we do not have read
    // access, then it will fail downstream returning a more
    // specific error related to what we do not have read
    // permissions on
    if (!(await fs_1.canAccess(repoDir))) {
        console.log(`\n${chalk_1.default.red(`Unable to find ${repoDir}`)}`);
        return null;
    }
    return await determineRepoRoot(repoDir);
}
exports.checkAccessAndDetermineRepoRoot = checkAccessAndDetermineRepoRoot;
async function determineFileChangeSet(remote, gitCommit) {
    const repoRoot = await checkAccessAndDetermineRepoRoot();
    if (!repoRoot) {
        return null;
    }
    // The GitHub action that checks out the repository checks it out
    // with --depth=0, so we fetch the commit we're going to diff
    // against to guarantee we have it locally.
    await safeFetch(repoRoot, remote, gitCommit);
    return await runDiffIndex(repoRoot, gitCommit);
}
exports.determineFileChangeSet = determineFileChangeSet;
/**
 * safeFetch attempts to fetch refOrCommit from remote, and
 * will fall back to fetching from origin. In either case,
 * it will not cause the script to crash.
 *
 * @param {string} repoRoot root of the repo
 * @param {string} remote the remote to fetch from
 * @param {string} refOrCommit the ref or commit to fetch
 */
async function safeFetch(repoRoot, remote, refOrCommit) {
    console.log(`\n${chalk_1.default.white(`Fetching ${refOrCommit} from ${remote}`)}`);
    try {
        await execGit(repoRoot, "fetch", remote, refOrCommit);
    }
    catch (error) {
        if (remote !== "origin") {
            console.log(`\n${chalk_1.default.yellow(`Fetch failed, attempting to fetch from origin`)}`);
            try {
                await execGit(repoRoot, "fetch", "origin", refOrCommit);
            }
            catch (error) {
                // No-op. Don't crash because the fetch attempts failed,
                // though we may fail downstream.
            }
        }
    }
}
exports.safeFetch = safeFetch;
async function runDiffIndex(repoRoot, gitCommit) {
    return await execGit(repoRoot, "diff-index", gitCommit, "--cached", "-M", "-C");
}
exports.runDiffIndex = runDiffIndex;
