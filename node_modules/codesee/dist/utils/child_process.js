"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exec = void 0;
const util_1 = require("util");
const childProcess = __importStar(require("child_process"));
const which_1 = require("./which");
const promises_1 = require("fs/promises");
const promiseExec = util_1.promisify(childProcess.exec);
/**
 * We always use stdout and stderr as strings, but the default typing is either
 * a string or a Buffer. To cause less problems downstream, we cast them as
 * strings here.
 *
 * @param cmd The command to execute
 * @param opts The options for the execution
 * @returns The stdout and stderr of the execution as strings
 */
async function stringExec(cmd, opts) {
    const { stdout, stderr } = await promiseExec(cmd, opts);
    return { stdout: stdout, stderr: stderr };
}
/**
 * This function takes the given command and executes it within an nsjail
 * sandbox.
 *
 * @param cmd The command to execute within the sandbox
 * @param opts The options for the execution
 * @returns The stdout and stderr of the execution as strings
 */
async function sandboxExec(cmd, opts) {
    const mountReadOnlyDirectories = await pruneNonExistentFiles([
        // These directories contain common executables and shared libraries, so we
        // mount them as read-only so many programs are functional.
        "/bin",
        "/lib",
        "/lib64",
        "/usr/bin",
        "/usr/lib",
        "/usr/local/bin",
        "/usr/local/lib",
        // This directory contains many symlinks back to bin directories, but there
        // are some symlinks in bin directories that point to /etc/alternatives, so
        // we need to make sure it's mounted as well. For example: /usr/bin/python
        // -> /etc/alternatives/python -> /usr/local/bin/python3.10.
        "/etc/alternatives",
        // Many programs expect to have /dev/null present.
        "/dev/null",
        ...(opts.mountReadOnlyDirectories || []),
    ]);
    const mountReadWriteDirectories = await pruneNonExistentFiles(opts.mountReadWriteDirectories || []);
    const envs = [
        // Many programs expect HOME to be set.
        "HOME",
        // If any explicit environment variables were set, we should probably allow
        // them as well.
        ...Object.keys(opts.env || {}),
    ];
    const maxMemoryMB = opts.maxMemoryMB || 100; // Default is 100MB
    const maxCores = opts.maxCores || 1; // Default is 1 core
    const limits = [
        // We disable the rlimits in general because it adds several of them that
        // conflict with some of our tooling (e.g. extra memory limits or limits to
        // file descriptors).
        "--disable_rlimits",
        "--cgroup_mem_max",
        (maxMemoryMB * 1024 * 1024).toString(),
        "--cgroup_cpu_ms_per_sec",
        (maxCores * 1000).toString(),
    ];
    const nsjail = await which_1.which("nsjail");
    const fullCmd = [
        nsjail,
        // Run in MODE_STANDALONE_ONCE mode which launches the command using clone.
        "--mode",
        "o",
        ...envs.flatMap((v) => ["--env", v]),
        ...limits,
        // Mount a temporary RW file system that will be cleaned up after execution
        // to /tmp.
        "--mount",
        "none:/tmp:tmpfs:size=8388608",
        // Mount read-only directories.
        ...mountReadOnlyDirectories.flatMap((directory) => [
            "--bindmount_ro",
            directory,
        ]),
        // Mount read-write directories.
        ...mountReadWriteDirectories.flatMap((directory) => [
            "--bindmount",
            directory,
        ]),
        // Change the user and group IDs to 99999 so that it has absolutely no extra
        // permissions.
        "--user",
        "99999",
        "--group",
        "99999",
        // nsjail prints out a lot of info and warn logs to stderr which can be
        // problematic in some cases.
        opts.quiet ? "--really_quiet" : "",
        "--",
        cmd,
    ].join(" ");
    return stringExec(fullCmd, opts);
}
async function exec(cmd, opts) {
    if (opts === null || opts === void 0 ? void 0 : opts.sandbox) {
        return sandboxExec(cmd, opts);
    }
    return stringExec(cmd, opts);
}
exports.exec = exec;
/**
 * Takes a list of files/directories and filters out any of them that don't exist.
 *
 * @param files Array of files/directories to prune
 * @returns Pruned array of files/directories
 */
async function pruneNonExistentFiles(files) {
    return (await Promise.all(files
        .filter((file) => file)
        // This needs to be a map, even though our main goal is filtering
        // because you can't use .filter with an async function. Because we need
        // to filter by an async value, we first need to map over the array with
        // our async function, which gives us an array of Promises. We can then
        // await on that using Promise.all and then we can filter the resulting
        // array.
        .map(async (file) => {
        // This checks if the file exists. If it does, it will return the
        // file. If it doesn't, it will return the empty string. We can then
        // filter afterwards to remove all directories that don't exist. This
        // is important because nsjail will err out if given a file that
        // doesn't exist.
        try {
            await promises_1.access(file);
            return file;
        }
        catch (_) {
            return "";
        }
    }))).filter((file) => file);
}
