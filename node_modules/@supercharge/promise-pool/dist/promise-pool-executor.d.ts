import { Stoppable } from './stoppable';
import { ReturnValue } from './return-value';
import { PromisePoolError } from './promise-pool-error';
export declare type ErrorHandler<T> = (error: Error, item: T, pool: Stoppable) => void | Promise<void>;
export declare type ProcessHandler<T, R> = (item: T, index: number, pool: Stoppable) => R | Promise<R>;
export declare class PromisePoolExecutor<T, R> implements Stoppable {
    private meta;
    /**
     * The async processing function receiving each item from the `items` array.
     */
    private handler;
    /**
     * The async error handling function.
     */
    private errorHandler?;
    /**
     * Creates a new promise pool executer instance with a default concurrency of 10.
     */
    constructor();
    /**
     * Set the number of tasks to process concurrently the promise pool.
     *
     * @param {Integer} concurrency
     *
     * @returns {PromisePoolExecutor}
     */
    withConcurrency(concurrency: number): this;
    /**
     * Returns the number of concurrently processed tasks.
     *
     * @returns {Number}
     */
    concurrency(): number;
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {Array} items
     *
     * @returns {PromisePoolExecutor}
     */
    for(items: T[]): this;
    /**
     * Returns the list of items to process.
     *
     * @returns {T[]}
     */
    items(): T[];
    /**
     * Returns the list of active tasks.
     *
     * @returns {Array}
     */
    tasks(): any[];
    /**
     * Returns the list of results.
     *
     * @returns {R[]}
     */
    results(): R[];
    /**
     * Returns the list of errors.
     *
     * @returns {Array<PromisePoolError<T>>}
     */
    errors(): Array<PromisePoolError<T>>;
    /**
     * Set the handler that is applied to each item.
     *
     * @param {Function} action
     *
     * @returns {PromisePoolExecutor}
     */
    withHandler(action: ProcessHandler<T, R>): this;
    /**
     * Determine whether a custom error handle is available.
     *
     * @returns {Boolean}
     */
    hasErrorHandler(): boolean;
    /**
     * Set the error handler function to execute when an error occurs.
     *
     * @param {Function} errorHandler
     *
     * @returns {PromisePoolExecutor}
     */
    handleError(handler?: (error: Error, item: T, pool: Stoppable) => Promise<void> | void): this;
    /**
     * Determines whether the number of active tasks is greater or equal to the concurrency limit.
     *
     * @returns {Boolean}
     */
    hasReachedConcurrencyLimit(): boolean;
    /**
     * Returns the number of active tasks.
     *
     * @returns {Number}
     */
    activeTasks(): number;
    /**
     * Stop a promise pool processing.
     */
    stop(): void;
    /**
     * Mark the promise pool as stopped.
     *
     * @returns {PromisePoolExecutor}
     */
    markAsStopped(): this;
    /**
     * Determine whether the pool is stopped.
     *
     * @returns {Boolean}
     */
    isStopped(): boolean;
    /**
     * Start processing the promise pool.
     *
     * @returns {ReturnValue}
     */
    start(): Promise<ReturnValue<T, R>>;
    /**
     * Determine whether the pool should stop.
     *
     * @returns {PromisePoolExecutor}
     *
     * @throws
     */
    validateInputs(): this;
    /**
     * Starts processing the promise pool by iterating over the items
     * and running each item through the async `callback` function.
     *
     * @param {Function} callback
     *
     * @returns {Promise}
     */
    process(): Promise<ReturnValue<T, R>>;
    /**
     * Wait for one of the active tasks to finish processing.
     */
    waitForTaskToFinish(): Promise<void>;
    /**
     * Create a processing function for the given `item`.
     *
     * @param {T} item
     * @param {number} index
     */
    startProcessing(item: T, index: number): void;
    /**
     * Ensures a returned promise for the processing of the given `item`.
     *
     * @param {T} item
     * @param {number} index
     *
     * @returns {*}
     */
    createTaskFor(item: T, index: number): Promise<any>;
    /**
     * Save the given calculation `result`.
     *
     * @param {*} result
     *
     * @returns {PromisePoolExecutor}
     */
    save(result: any): this;
    /**
     * Remove the given `task` from the list of active tasks.
     *
     * @param {Promise} task
     */
    removeActive(task: Promise<void>): this;
    /**
     * Create and save an error for the the given `item`.
     *
     * @param {T} item
     */
    handleErrorFor(error: Error, item: T): Promise<void>;
    /**
     * Determine whether the given `error` is a `StopThePromisePoolError` instance.
     *
     * @param {Error} error
     *
     * @returns {Boolean}
     */
    isStoppingThePool(error: Error): boolean;
    /**
     * Run the user’s error handler, if available.
     *
     * @param {Error} processingError
     * @param {T} item
     */
    runErrorHandlerFor(processingError: Error, item: T): Promise<void>;
    /**
     * Rethrow the given `error` if it’s not an instance of `StopThePromisePoolError`.
     *
     * @param {Error} error
     */
    rethrowIfNotStoppingThePool(error: Error): void;
    /**
     * Create and save an error for the the given `item`.
     *
     * @param {T} item
     */
    saveErrorFor(error: Error, item: T): void;
    /**
     * Wait for all active tasks to finish. Once all the tasks finished
     * processing, returns an object containing the results and errors.
     *
     * @returns {Object}
     */
    drained(): Promise<ReturnValue<T, R>>;
    /**
     * Wait for all of the active tasks to finish processing.
     */
    drainActiveTasks(): Promise<void>;
}
