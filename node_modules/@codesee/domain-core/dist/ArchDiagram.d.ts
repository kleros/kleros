import { GenericMap, PackageNamePath } from "./types";
interface Logger {
    error?: (str: string) => void;
    warn?: (str: string) => void;
    info?: (str: string) => void;
}
/**
 * Shape of the JSON blob stored in the database
 *
 * Top Level Y.Doc
 */
export declare type ServerBlob = {
    nodes: ArchDiagramNode[];
    links: ArchDiagramLink[];
    labels: LabelConfig[];
    tours: SerializedTourCollection;
};
export declare type SerializedTourCollection = SerializedTour[] | GenericMap<SerializedTour>;
export declare type SerializedTour = Pick<Tour, "name" | "steps" | "id">;
/**
 * We store a cache on each Group mapping LabelConfig.key -> count of Nodes with that label.
 * We use this information to decide how we will color each group. If the count of nodes is
 * zero for every label key expect one, then we color the group with that label.
 *
 * Y.Map
 * Future Improvement: Remove the label counts cache from the Y.Doc
 */
export declare type LabelCounts = {
    [labelKey: string]: number;
};
export declare type LabelConfig = {
    key: string;
    name: string;
    color: string;
    backgroundColor: string;
};
export declare enum AlertType {
    TourConflict = "tour-conflict"
}
/**
 * TourStepConflict is calculated when a new dependency map is uploaded
 * This allows us to notify the user when they will need to update the tour
 * because the node it refers to changed in a way that we can't handle.
 *
 * Without RTCE, this is calculated when we merge the new dependency map into the snapshot.
 * With RTCE, we calculate this as part of the lambda that updates the Y.Doc
 *
 * POJsO
 */
export declare type TourStepConflict = {
    type: "moved" | "deleted" | "hidden";
    commitSHA: string;
    commitURL: string;
    timestamp: number;
};
/**
 * Y.Map
 */
export declare type TourStep = {
    id: string;
    message: string;
    nodeKey: string;
    conflict?: TourStepConflict;
};
/**
 * Y.Map
 */
export declare type Tour = {
    id: string;
    name: string;
    steps: TourStep[];
    selectedStep?: number;
};
/**
 * Y.Array or Y.Map
 */
export declare type TourCollection = Tour[] | GenericMap<Tour>;
/**
 * A node that is either a file or a group.
 *
 * `expanded` only exists for groups
 *
 * future improvement thought: discriminated union so that `node := groupNode âˆª fileNode`
 * with isGroup determining if it's a file or group so that we can be more specific with types
 * where we need them to be.
 *
 * Y.Map
 */
export declare type ArchDiagramNode = {
    key: string;
    uuid?: string;
    name: string;
    packageName?: string;
    group?: string;
    x?: number;
    y?: number;
    isGroup?: boolean;
    expanded?: boolean;
    labelKey?: string;
    labelCounts?: LabelCounts;
    isSubGraphExpanded?: boolean;
    note?: string;
    hidden?: boolean;
};
/**
 * Note that only the `to` and `from` properties are serialized into the JSON
 * blob we send to the server.
 *
 * Y.Map
 */
export declare type ArchDiagramLink = {
    from: string;
    to: string;
    color?: string;
};
/**
 * Used to denote that something is changing location. This can be a move or a copy
 */
export declare type Migration = {
    to: string;
    from: string;
};
export declare type DependencyMapV2 = {
    version: "2";
    commitHash: string;
    nodes: ArchDiagramNode[];
    links: ArchDiagramLink[];
    packageNamePaths?: PackageNamePath[];
};
export declare type DependencyMapFullV3 = {
    version: "3";
    mode: "full";
    commitHash: string;
    linkLanguages: {
        [key: string]: boolean;
    };
    previousDependencyMapCommit?: string;
    fileChangeSet?: string | null;
    nodes: ArchDiagramNode[];
    links: ArchDiagramLink[];
    packageNamePaths?: PackageNamePath[];
};
export declare type DependencyMapIncrementalV3 = {
    version: "3";
    mode: "incremental";
    commitHash: string;
    linkLanguages: {
        [key: string]: boolean;
    };
    previousDependencyMapCommit: string;
    fileChangeSet: string;
    nodes: ArchDiagramNode[];
    links: ArchDiagramLink[];
};
export declare type DependencyMapFullV4 = Omit<DependencyMapFullV3, "version" | "mode"> & {
    version: "4";
    mode: "full" | "computed-full";
    packageNamePaths: PackageNamePath[];
    packageNamePathLanguages: {
        [key: string]: boolean;
    };
};
export declare type DependencyMapIncrementalV4 = Omit<DependencyMapIncrementalV3, "version"> & {
    version: "4";
    packageNamePaths?: PackageNamePath[];
    packageNamePathLanguages: {
        [key: string]: boolean;
    };
};
export declare type DependencyMapV3 = DependencyMapFullV3 | DependencyMapIncrementalV3;
export declare type DependencyMapV4 = DependencyMapFullV4 | DependencyMapIncrementalV4;
export declare type DependencyMap = DependencyMapV2 | DependencyMapV3 | DependencyMapV4;
/**
 * A list of changes that need to be applied to a snapshot/diagram.
 * This is used during all structural modifications (merging), and is calculated
 * from a combination of diffing of the before  and after state and using `git diff-index`
 */
export declare type ChangeSpec = {
    adds: string[];
    removes: string[];
    modifications: string[];
    renames: Migration[];
    copies: Migration[];
    linkAdds: ArchDiagramLink[];
    linkRemoves: ArchDiagramLink[];
};
/**
 * How to use in various forms
 *
 * From Database into Domain Object:
 *
 * const diagram = plainToClass(ArchDiagram, fromDb, {
 *    excludeExtraneousValues: true,
 * });
 * // You can now call methods on diagram
 *
 *
 * From Domain Object to Database Ready Pojo
 *
 * const pojoDiagram = classToPlain(diagram);
 * // You can then serialize the pojoDiagram
 */
export declare class ArchDiagram {
    nodes: ArchDiagramNode[];
    links: ArchDiagramLink[];
    tours: TourCollection;
    version: string;
    commitHash: string;
    constructor();
    applyChanges(logger: Logger, changes: ChangeSpec): boolean;
    eliminateInvalidLinks(packages: string[]): boolean;
    eliminateDuplicateLinks(): boolean;
    removeEmptyGroups(): void;
    checkToursForConflicts(gitCommit: string, commitUrl: string): void;
    /**
     * Abstracts away the type difference while we migrate from Y.Array to Y.Map
     *
     * @returns an array of all the values of the TourCollection
     *          for iterating over them
     */
    private getTourIter;
    private addNodesForChanges;
    private removeNodesForChanges;
    private renameNodesForChanges;
    private copyFilesForChanges;
    private removeNode;
    private assignGroups;
    generateMissingGroups(): boolean;
    updateGroupLabelCounts(): void;
}
/**
 * Given an incremental dependency map, use the file change set data it
 * contains along with a previous full dependency map from the same
 * repository to compute the current full dependency map and return it.
 *
 * TODO ENG-781: Investigate breaking this into several helper functions.
 *
 * @param {DependencyMapIncrementalV3 | DependencyMapIncrementalV4} incrementalData - an
 *   incremental dependency map in the v3 or v4 format.
 * @param {DependencyMapV2 | DependencyMapFullV3 | DependencyMapFullV4} previousFullMap - a
 *   full dependency map in either v2, v3, or v4 format
 * @returns {DependencyMapFullV4} a full dependency map in the V4 format.
 */
export declare function computeFullDependencyMapFromIncrementalDependencyMap(incrementalData: DependencyMapIncrementalV3 | DependencyMapIncrementalV4, previousFullMap: DependencyMapV2 | DependencyMapFullV3 | DependencyMapFullV4): DependencyMapFullV4;
export declare function parseFileChangeSet(fileChangeSet: string): ChangeSpec;
/**
 * This function normalizes a filename that is received from `git diff-index`.
 *
 * From git docs:
 * > Commands that output paths (e.g. ls-files, diff), will quote "unusual"
 *   characters in the pathname by enclosing the pathname in double-quotes
 *   and escaping those characters with backslashes in the same way C escapes
 *   control characters (e.g. \t for TAB, \n for LF, \\ for backslash) or bytes
 *   with values larger than 0x80 (e.g. octal \302\265 for "micro" in UTF-8).
 *
 * Unusual characters:
 *   We've tested all characters between 1-126. Characters 127+ are all octal encoded
 *   1-6:    octal encoded
 *   7:      "\a"
 *   8:      "\b"
 *   9:      "\t"
 *   10:     "\n"
 *   11:     "\v"
 *   12:     "\f"
 *   13:     "\r"
 *   14-31:  octal encoded
 *   32 ( ): no encoding
 *   33 (!): no encoding
 *   34 ("): "\""
 *   35-46:  no encoding
 *   47 (/): forward slash cannot be in a filename
 *   48-91:  no encoding
 *   92 (\): "\\"
 *   93-126: no encoding
 *   127+:   octal encoding
 *
 * It does the following normalizations:
 * - Trim off leading and trailing double quotes.
 * - Convert escaped double quotes to regular quotes. A quoted file will appear
 *   as "\"quoted\".txt" and we want it as "quoted".txt.
 * - Convert a series of octal bytes into the Unicode character that it
 *   represents. Git will convert Unicode characters (e.g. emojis) into a series
 *   of octal bytes. For example, ðŸ”¥ will appear as \360\237\224\245.
 *
 * All these cases are tested in change-set.spec.ts and normalize-filename.spec.ts
 * so you can see it in action if you check the tests.
 *
 * @param filename The filename that needs to be normalized
 * @returns The normalized filename
 */
export declare function normalizeFilename(filename: string): string;
export declare function dirnameOrUndefined(fullPath: string): string | undefined;
export {};
